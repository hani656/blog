---
title: 面试
---

# 前端基础

## 1.h5的新特性？css3的新特性？

### H5新特性

1. 拖拽释放api

2. 自定义属性data-id

3. 语义化标签

4. audio、video

5. canvas

6. 地理api

7. localStorage、sessionStorage

8. 表单控件

9. webworker、websocket

   | 不同点                                  | 备注说明                                                     |
   | --------------------------------------- | ------------------------------------------------------------ |
   | 只有一种 DOCTYPE ⽂件类型声明(统一标准) | `<!DOCTYPE html>`                                            |
   | 增加了一些新的标签元素(功能, 语义化)    | **section**, **video**, progress, **nav**, meter, time, **aside**, **canvas**, command, datalist, details, embed, figcaption, figure, **footer**, **header**, hgroup... |
   | input 支持了几个新的类型值              | `date, email, url` 等等                                      |
   | 新增了一些标签属性                      | charset（⽤于 meta 标签）；async（⽤于 script 标签）         |
   | 新增的全域属性                          | contenteditable, draggable、hidden                           |
   | 新增API                                 | 本地存储, 地理定位, Canvas绘图, 拖拽API, 即时通信WebSocket... |

### css3新特性

1. rgba (包含了颜色的红、绿、蓝和透明度（alpha）四个通道)
2. border-radius
3. 盒子模型
4. 线性渐变
5. 过渡
6. 动画
7. flex
8. 字体图标

## 标准盒模型和怪异盒模型有哪些区别？

**盒模型的指定：**

在CSS3中，我们可以通过设置 box-sizing 的值来决定具体使用何种盒模型：

- content-box    标准盒模型
- border-box     怪异盒模型

**标准盒模型：**

box-sizing: content-box; (默认值)

标准盒模型又称W3C标准盒模型，其中标准盒模型的 width 等于 content 的宽度，标准盒模型的 height 等于 content 的高度。
**标准盒大小计算公式：width(content) + padding + border + margin**

![alt text](前端面试手册.assets/image-20210214150511841.png)

**怪异盒模型：**

box-sizing: border-box; (目前主流常用值)

怪异盒模型又称IE盒子模型，其中怪异盒子模型的 width 等于 content + padding + border 的宽度，怪异盒子模型的 height 等于 content + padding + border 的高度。
**怪异盒大小的计算公式：width(content + padding + border) + margin**

![alt text](前端面试手册.assets/image-20210214151037552.png)

[参考文章：深入理解盒模型](https://www.cnblogs.com/xiaohuochai/p/5202597.html)

## 2.盒子水平（垂直）居中

1. **方法一：使用 margin**

   通过为元素设置左右的 margin 为 auto，实现让元素居中。

   ```html
   <div class="center">本内容会居中</div>
   ```

   ```scss
   .center {
      height: 500px;
      width: 500px;
      background-color: pink;
      margin: 0 auto;
   }
   ```

   **方式二: 转成行内块,  给父盒子设置 text-align: center**

   ```html
   <div class="father">
    <div class="center">我是内容盒子</div>
   </div>
   ```

   ```css
   .father {
     text-align: center;
   }
   .center {
     width: 400px;
     height: 400px;
     background-color: pink;
     display: inline-block;
   }
   ```

   **方法三：使用 flex 布局**

   使用 flex 提供的子元素居中排列功能，对元素进行居中。

   ```html
   <div class="father">
    <div class="center">我是内容盒子</div>
   </div>
   ```

   ```css
   .father {
     display: flex;
     background-color: skyblue;
     justify-content: center;
     align-items: center;
   }
   .center {
     width: 400px;
     height: 400px;
     background-color: pink;
   }
   ```

   **方式四: 使用定位布局**

   ```html
   <div class="father">
     <div class="center">我是内容盒子</div>
   </div>
   ```

   ```css
   .father {
     background-color: skyblue;
     position: relative;
     height: 500px;
   }
   .center {
     width: 400px;
     height: 400px;
     background-color: pink;
     position: absolute;
     left: 50%;
     top: 50%;
     transform: translate(-50%, -50%);
   }
   ```

   [【更多方式参考】实现水平居中垂直居中](https://www.cnblogs.com/chengxs/p/11231906.html)

## 3.css选择器优先级

！Important>行内样式>ID 选择器>类选择器>标签>通配符>继承>浏览器默认属性

## 4.rem的理解

rem 是 CSS3 新增的一个相对单位（root em，根 em），是做移动端适配用的方法，使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。如果根元素的字体大小为16px，那么1rem等于16px

`rem` 单位只相对于文档的**根元素**，也就是html的字体大小；而 `em` 单位相对于父元素的字体大小。

**rem把屏幕等分成的了10份,如一个屏幕宽度为375,那么用rem编写网页就是, 37.5rem.**

手淘方案：

1. 拿到设计稿除以 10，得到 font-size 基准值
2. 引入 flexible
3. 设计稿 px/ font-size 基准值，即可换算为 rem

## 5.position

1. static 静态定位（默认值）：不脱离文档流
2. absolute 绝对定位 ：找最近一级带有定位的父级元素进行移动 脱离文档流
3. relative 相对定位  不脱离文档流
4. fixed 固定定位 脱离文档流 参照物浏览器窗口
5. sticky 粘性定位  不脱离文档流

## 6.浮动 float

浮动将元素排除在普通流之外，即元素将脱离文档流，不占据空间。浮动元素碰到包含它的边界或者浮动元素的边界停留。

1、子元素浮动后，不占位置，父元素的高度无法被撑开，影响与父元素同级的元素；

2、与浮动元素同级的非浮动元素（内联元素）会跟随其后；

3、若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构   解决方法

清除浮动

1. 额外标签法  clear：both（使用一个空的div，并设置样式）

2. 双伪元素清除法

3. 单伪元素清除法

4. 构建BFC  为父元素添加 `overflow: hidden`   溢出隐藏

5. 定高法

BFC 的全称是 Block Formatting Context，**块级格式化上下文**。这是一个用于在盒模型下布局块级盒子的独立渲染区域，

将处于BFC区域内和区域外的元素进行互相隔离。

**何时会形成 BFC：**

满足下列条件之一就可触发BFC：

- position 值为 `absolute` 或 `fixed`
- float 值不为 `none`
- overflow 值不为 `visible`（为 hidden、scroll、auto时触发BFC）
- display 值为 `inline-block`、`flex`、`table-cell` 或 `table-caption`

**作用：**

1. 清除浮动
2. 避免margin塌陷
3. 实现自适应布局, 防止元素被浮动元素覆盖(左边固定, 右边自适应)

## 7. 伪类和伪元素

伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的; 例如  `:checked`、`:hover`、`:disabled`、 `:first-child`等

伪元素：用于创建一些不在DOM树中的元素，并为其添加样式 ; 例如，我们可以通过  :before  :after

### 两者的区别

虽然它们在语法上是一致的，但是它们的功能区别还是非常明显的。

- 伪类是用来匹配元素的特殊状态的
- 伪元素是用来匹配元素的隶属元素的，这些隶属元素可以在界面中展示，但在 DOM 中不体现

## 8.css预处理器

Less、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率

Less和Sass是两种CSS预处理器，它们有以下区别：

1. 编译环境：Less基于JavaScript，在客户端处理；Sass基于Ruby，在服务器端处理。这可能导致一些开发者不会选择Less，因为JavaScript引擎需要额外的时间来处理代码，然后输出修改过的CSS到浏览器。但这可以通过在开发环节使用Less，一旦完成开发，就复制粘贴Less输出的样式到一个压缩器，然后到一个单独的CSS文件来替代Less文件，或者使用Less.app来编译和压缩Less文件等方式解决。
2. 变量声明：Less用@，Sass用$。
3. 混合器写法：Less和Sass在混合器的写法上有所不同。
4. 文件名：如果文件名以下划线开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件，而Less则没有这样的要求。
5. 工具库：Sass有工具库Compass，在其基础上封装了一系列有用的模块和模板，补充强化了Sass的功能；而Less则有UI组件库Bootstrap。

总的来说，Less和Sass在编译环境、变量声明、混合器写法、对文件名的要求以及工具库方面存在区别。

### 两者区别

1. 实现方式：Less是基于JavaScript，在客户端进行处理；而Sass是基于Ruby，在服务器端进行处理。
2. 变量定义：在Less中，变量以@开头，如@mainColor: #963;而在Sass中，变量以$开头，如blue: #1875e7。

## 9.vw适配

是做移动端适配用的方法，vw/vh就是视口的宽/高，vw把屏幕的宽等分成100份,如一个屏幕宽度为375,那么1vw = 3.75vw.

- 开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）
- 开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，换成vw为 (100/750)*32 vw
- 对于需要等比缩放的元素，CSS使用转换后的单位
- 对于不需要缩放的元素，比如边框阴影，使用固定单位px

## **10.如何解决 margin“塌陷”？**

**外边距塌陷共有两种情况：**

第一种情况：两个同级元素，垂直排列，上面的盒子给 margin-bottom 下面的盒子给margin-top，那么他们两个的间距会重叠，以大的那个计算。解决这种情况的方法为：两个外边距不同时出现

第二种情况：两个父子元素，内部的盒子给 margin-top，其父级也会受到影响，同时产生上边距，父子元素会进行粘连。

**解决方案：**

1、为父盒子设置 border，添加 border 后父子盒子就不是真正意义上的贴合（可以设置成透明：border：1px solid transparent）；

2、为父盒子设定 padding 值；

3、为父盒子添加 overflow：hidden；

4、为父盒子添加 position：fixed；

5、为父盒子添加 display：table；

## 11. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？

| 方式                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| opacity: 0            | 通过将元素的透明度设置为0，实现看起来隐藏的效果；但是依然会占用空间并可以进行交互 |
| visibility: hidden    | 与透明度为0的方案非常类似，会占据空间，但不可以进行交互      |
| overflow: hidden      | 只会隐藏元素溢出的部分；占据空间且不可交互                   |
| display: none         | 可以彻底隐藏元素并从文档流中消失，不占据空间也不能交互，且不影响布局 |
| z-index: -9999        | 通过将元素的层级置于最底层，让其他元素覆盖住它，达到看起来隐藏的效果 |
| transform: scale(0,0) | 通过将元素进行缩放，缩小为0；依然会占据空间，但不可交互,只是一个视觉效果，不会影响其它盒子的布局。 |
| left: -9999px         | 通过将元素定位到屏幕外面，达到看起来看不到的效果             |

## 12. 如何理解 z-index？

可以将它看做三维坐标系中的z轴方向上的图层层叠顺序。

元素默认的 z-index 为 0，可通过修改 z-index的图层位置。

`z-index的小坑, 如果父辈元素有定位, 且配置了z-index, 优先按照父辈元素的定位的z-index进行比较层级，当前盒子的z-index层级只是在父元素里面的层级`

## 13. 谈谈你对 flex 的理解？

在真实的应用场景中，通常会遇到各种各样不同尺⼨和分辨率的设备，为了能在所有这些设备上正常的布局我们的应用界面，就需要响应式的界⾯设计方式来满⾜这种复杂的布局需求。

**flex 弹性盒模型** 的优势在于开发⼈员只需要声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒子布局。

你能联想到的flex语法有哪些呢?

`flex-direction`: 调整主轴方向

```txt
row：主轴方向为水平向右
column：主轴方向为竖直向下
row-reverse:主轴方向为水平向左
column-reverse:主轴方向是竖直向上。
```

`justify-content`主要用来设置**主轴方向的对齐方式**

```txt
flex-start: 弹性盒子元素将向起始位置对齐
flex-end: 弹性盒子元素将向结束位置对齐。
center: 弹性盒子元素将向行中间位置对齐
space-around: 弹性盒子元素会平均地分布在行里
space-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。
```

`align-items`用于调整**侧轴的对齐方式**

```txt
flex-start： 元素在侧轴的起始位置对齐。 
flex-end： 元素在侧轴的结束位置对齐。
center： 元素在侧轴上居中对齐。
stretch： 元素的高度会被拉伸到最大（不给高度时, 才拉伸）。
```

`flex-wrap`属性控制flex容器是单行或者多行,默认不换行

```txt
nowrap： 不换行（默认），如果宽度溢出，会压缩子盒子的宽度。
wrap： 当宽度不够的时候，会换行。
```

`align-content`用来设置多行的flex容器的排列方式

```txt
flex-start： 各行向侧轴的起始位置堆叠。 
flex-end： 各行向弹性盒容器的结束位置堆叠。
center： 各行向弹性盒容器的中间位置堆叠。
space-around： 各行在侧轴中平均分布。 
space-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 
stretch：拉伸，不设置高度的情况下。
```

> 可参考 [flex布局教程](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

---

## JavaScript

## 1. let var const的区别？

**var ES5变量声明方式:**

1. 在变量未赋值时，变量undefined（为使用声明变量时也为undefined）
2. 作用域： var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用

**let ES6变量声明方式:**

1. 在变量未声明前直接使用会报错
2. 作用域   let为块级作用域   通常let比var范围要小
3. let禁止 重复声明变量，否则会报错；var可以重复声明

**const ES6变量声明:**

1. const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改常量的值
2. const实际上保证的，并不是变量的值不得改动，而是变量指向的哪个内存地址不得改动

## 变量提升

变量提升（hoisting），是负责解析执行代码的 JavaScript 引擎的工作方式产生的一个特性。

JS引擎在运行一份代码的时候，会按照下面的步骤进行工作：

1. 首先，对代码进行预解析，并获取声明的所有变量

2. 然后，将这些变量的声明语句统一放到代码的最前面

3. 最后，开始一行一行运行代码

## JS 的参数是以什么方式进行传递的

- **基本类型：是值传递**
- **复杂类型: 传递的是地址! (变量中存的就是地址)**

## 2. js数据类型，区别

**基本数据类型：**

number，string，boolean，null，undefined，symbol（独一无二的值，ES6 新增），bigint（大整数，能够表示超过 Number 类型大小限制的整数）

**引用数据类型：**

- Object（对象）
- Function（函数）
- Array（数组）

object：普通对象，正则对象，日期对象，math数学函数对象。

(NaN 是一个数值类型，但不是一个具体的数字。)

## 检测数据类型方法

1. **typeof**

通常用来判断**基本数据类型**，它**返回表示数据类型的字符串**（返回结果只能包括number,boolean,string,undefined，object）；

*注意，**使用typeof来判断null和引用类型的实例 返回的结果都是 'object'**
可以使用typeof判断变量是否存在（如if(typeof a!="undefined"){...}）；

```js
typeof 1           //number
typeof 'a'         //string
typeof true        //boolean
typeof undefined   //undefined
 
typeof null        //object
 
typeof {}          //object
typeof [1,2,3]     //object
 
function Fn(){}
typeof new Fn()    //object
 
typeof new Array() //object
```

2. **instanceof**

原理 因为A instanceof B 可以判断A是不是B的实例，返回一个布尔值，由构造类型判断出数据类型

```js
console.log(arr instanceof Array ); // true
console.log(date instanceof Date ); // true
console.log(fn instanceof Function ); // true
//注意： instanceof 后面一定要是对象类型，大小写不能写错，该方法试用一些条件选择或分支
```

3. **根据对象的contructor判断**

```js
console.log('数据类型判断' -  constructor);
console.log(arr.constructor === Array); //true
console.log(date.constructor === Date); //true
console.log(fn.constructor === Function); //true
```

4. **通过Object下的toString.call()方法来判断**

```js
Object.prototype.toString.call();
console.log(toString.call(123)); //[object Number] 返回的是字符串数组
console.log(toString.call('123')); //[object String]
console.log(toString.call(undefined)); //[object Undefined]
console.log(toString.call(true)); //[object Boolean]
console.log(toString.call({})); //[object Object]
console.log(toString.call([])); //[object Array]
console.log(toString.call(function(){})); //[object Function]
```

## 数据类型的转换方法

1. **转换为字符串**：

使用 `toString()` 方法可以将非字符串的数据类型转换为字符串。

```javascript
let num = 123;  
let str = num.toString();  // "123"
```

1. **转换为数字**：

- 使用 `Number()` 函数或 `parseInt()` 和 `parseFloat()` 方法可以将字符串转换为数字。

```javascript
let str = "123";  
let num = Number(str);  // 123  
let intNum = parseInt(str);  // 123  
let floatNum = parseFloat(str);  // 123.0
```

- 使用一元加号 `+` 运算符也可以实现类似的效果：

```javascript
let str = "123";  
let num = +str;  // 123
```

1. **转换为布尔值**：

使用 `Boolean()` 函数可以将任何数据类型转换为布尔值。

```javascript
let truthy = Boolean(1);  // true  
let falsy = Boolean(0);  // false  
let emptyString = Boolean("");  // false  
let nonEmptyString = Boolean("hello");  // true
```

1. **转换为数组**：

- 使用 `Array.from()` 方法可以将类似数组的对象或可迭代的对象转换为数组。

```javascript
let iterable = {0: 'a', 1: 'b', 2: 'c', length: 3};  
let arr = Array.from(iterable);  // ['a', 'b', 'c']
```

- 使用扩展运算符 `...` 也可以实现类似的效果：

```javascript
let iterable = {0: 'a', 1: 'b', 2: 'c', length: 3};  
let arr = [...iterable];  // ['a', 'b', 'c']
```

1. **对象与JSON的转换**：

- 使用 `JSON.stringify()` 方法可以将JavaScript对象转换为JSON字符串。

```javascript
let obj = {name: "John", age: 30};  
let jsonString = JSON.stringify(obj);  // '{"name":"John","age":30}'
```

- 使用 `JSON.parse()` 方法可以将JSON字符串转换为JavaScript对象。

```javascript
let jsonString = '{"name":"John","age":30}';  
let obj = JSON.parse(jsonString);  // {name: "John", age: 30}
```

## JavaScript垃圾回收

JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。

正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题，

但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。

### 内存的生命周期

JS环境中分配的内存, 一般有如下生命周期：

1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存

2. 内存使用：即读写内存，也就是使用变量、函数等

3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存

   全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉

### 垃圾回收算法说明

所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉

下面介绍两种常见的浏览器垃圾回收算法: 引用计数 和 标记清除法

### 引用计数

IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。

如果没有任何变量指向它了，说明该对象已经不再需要了。

```jsx
// 创建一个对象person, person指向一块内存空间, 该内存空间的引用数 +1
let person = {
    age: 22,
    name: 'ifcode'
}

let p = person   // 两个变量指向一块内存空间, 该内存空间的引用数为 2
person = 1       // 原来的person对象被赋值为1，对象内存空间的引用数-1,
                 // 但因为p指向原person对象，还剩一个对于对象空间的引用, 所以对象它不会被回收

p = null         // 原person对象已经没有引用，会被回收
```

由上面可以看出，引用计数算法是个简单有效的算法。

**但它却存在一个致命的问题：循环引用。**

如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。

```jsx
function cycle() {
    let o1 = {}
    let o2 = {}
    o1.a = o2
    o2.a = o1 
    return "Cycle reference!"
}

cycle()
```

![image-20210305172448582](images/image-20210305172448582.png)

### 标记清除算法

现代的浏览器已经不再使用引用计数算法了。

现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。

标记清除法:

- 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。

- 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。

- 凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。

根据这个概念，上面的例子可以正确被垃圾回收处理了。

参考文章：[JavaScript内存管理](https://www.jianshu.com/p/84a8fd5fa0ee)

## 3.slice 是干嘛的、splice是否会改变原数组？

1. slice 是来截取的  参数可以写 slice(3)、slice(-3)、slice(1,3) 返回的是一个新的数组（注意：不改变原数组）

2. splice 功能有：插入、删除、替换

   返回：删除的值

   array.splice( start,  deleteCount,  item1,  item2, ...);

   - `start`：必需。一个整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
   - `deleteCount`：可选。要删除的项目数量。如果设置为 0，则不会删除项目。
   - `item1, item2, ...`：可选。向数组添加的新项目。

   该方法会改变原数组

## 4.数组去重

```js
const arr = [1,2,3,2]

function unique(arr) {
    return [...new Set(arr)]
}
console.log(unique(arr))
```

## 5. **Javascript 创建对象的几种方式？**

1. 简单对象的创建 使用对象字面量的方式{}

```javascript
const Cat = {};
```

2. new 一个function-

```javascript
function Person(){
}
const personOne=new Person();
```

3. 使用工厂方式来创建（Object 关键字）

```javascript
const wcDog =new Object();
```

4. 使用 Object.create() 创建对象（使用现有对象作为原型）

```javascript
const person = Object.create(anotherPerson);
```

5. 使用 ES6 中的类（Class）创建对象（其实质还是使用构造函数）：

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}
const person = new Person('John');
```

## 6. 如何区分数组和对象？

1. 通过 ES6 中的 Array.isArray

```javascript
Array.isArray([]) //true
Array.isArray({}) //false
```

2. 通过 instanceof 来识别

```javascript
[] instanceof Array //true
{} instanceof Array //false
```

3. 通过调用 constructor 来识别

```javascript
{}.constructor //返回 object
[].constructor //返回 Array
```

4. 通过 Object.prototype.toString.call 方法来识别

```javascript
Object.prototype.toString.call([]) //["object Array"]
Object.prototype.toString.call({}) //["object Object"]
```

## 判断两个对象是否相等

① 方法一：通过JSON.stringify(obj)来判断两个对象转后的字符串是否相等

优点：用法简单，对于顺序相同的两个对象可以快速进行比较得到结果
缺点：这种方法有限制就是当两个对比的对象中key的顺序不是完全相同时会比较出错

② 方法二：Object.getownPropertyNames(）

1.用Object.getOwnPropertyNames拿到对象的所有键名数组
2.比对键名数组的长度是否相等
3.比对键名对应的键值是否相等

缺点：对象属性是对象的情况要进行递归
————————————————

## 6.1  数组遍历的方法

1. **for循环**：这是最基本和最常用的遍历方式。

   ```js
   let arr = [1, 2, 3, 4, 5];  
   for(let i = 0; i < arr.length; i++) {  
       console.log(arr[i]);  
   }
   ```

2. **for...of循环**：这是ES6中引入的新的遍历方式，可以直接访问数组中的每个元素，而不需要使用索引

   ```js
   let arr = [1, 2, 3, 4, 5];  
   for(let value of arr) {  
       console.log(value);  
   }
   ```

3. **forEach方法**：这种方法也是非常常用的，它会对数组中的每个元素执行一次提供的函数

   ```js
   let arr = [1, 2, 3, 4, 5];  
   arr.forEach(function(value) {  
       console.log(value);  
   });
   ```

5. **map方法**：这种方法会创建一个新的数组，其结果是调用提供的函数在每个元素上的结果

   ```js
   let arr = [1, 2, 3, 4, 5];  
   let newArr = arr.map(function(value) {  
       return value * 2;  
   });  
   console.log(newArr);  // [2, 4, 6, 8, 10]
   ```

6. **filter方法**：这种方法会创建一个新的数组，包含通过提供的函数实现的测试的所有元素。

   ```js
   let arr = [1, 2, 3, 4, 5];  
   let newArr = arr.filter(function(value) {  
       return value > 2;  
   });  
   console.log(newArr);  // [3, 4, 5]
   ```

7. **reduce方法**：这种方法会将数组中的所有元素减少到单个值。这通常用于将数组中的所有元素组合成一个值。

   ```js
   let arr = [1, 2, 3, 4, 5];  
   let sum = arr.reduce(function(prev, current) {  
       return prev + current;  
   }, 0);  // sum will be 15
   ```

7. **includes（）方法**

```js
 array.includes(searchElement[, fromIndex])
// searchElement：需要查找的元素，必选。
// fromIndex：可选，从该索引处开始查找元素。如果省略该参数，则从数组的头开始查找。如果 fromIndex 大于或等于数组长度，则返回 false。
```

```js
const fruits = ["apple", "banana", "orange", "grape"];

console.log(fruits.includes("banana"));  // true
console.log(fruits.includes("watermelon"));  // false
console.log(fruits.includes("apple", 1));  // false
console.log(fruits.includes("apple", -2));  // false
```

## 6.2 数组求最大值最小值

**使用Math.max()方法：**

```js
const arr = [1, 2, 3, 4, 5];
const max = Math.max(...arr);
console.log(max); // 输出：5
```

**使用reduce()方法：**

```js
const arr = [1, 2, 3, 4, 5];
const max = arr.reduce((a, b) => Math.max(a, b));
console.log(max); // 输出：5
```

**使用sort()方法：**

```js
const arr = [1, 2, 3, 4, 5];
arr.sort((a, b) => b - a);
const max = arr[0];
console.log(max); // 输出：5
```

**使用apply()方法：**

```js
const arr = [1, 2, 3, 4, 5];
const max = Math.max.apply(null, arr);
console.log(max); // 输出：5
```

**使用for循环：**

```js
const arr = [1, 2, 3, 4, 5];
let max = arr[0];
for (let i = 1; i < arr.length; i++) {
  if (arr[i] > max) {
    max = arr[i];
  }
}
console.log(max); // 输出：5
```

这种方法使用for循环遍历数组，逐个比较元素并更新最大值。

**使用递归：**

```js
function findMax(arr) {
  if (arr.length === 1) {
    return arr[0];
  } else {
    return Math.max(arr[0], findMax(arr.slice(1)));
  }
}
const arr = [1, 2, 3, 4, 5];
const max = findMax(arr);
console.log(max); // 输出：5
```

这种方法使用递归的方式，每次比较数组的第一个元素和剩余元素的最大值。

## js中如何计算小数（排除误差干扰）

1. 保留小数位数toFixed()

```js
(0.1+0.2).toFixed() //"0.3"
```

 注意：toFixed()保留完是字符串，需要转数字类型

```js
typeof (0.1 + 0.2).toFixed(2) // "string"

parseFloat((0.1 + 0.2).toFixed(2)) // 0.3

typeof parseFloat((0.1 + 0.2).toFixed(2)) // "number"
```

2. 可以通过先乘10的倍数，然后再除，比如 我要保留两位小数 那我就乘100，运算完后再除100

```js
(0.1*10 + 0.2*10) / 10 // 0.3
(33.01*100 - 5*100) / 100 // 28.01
```

**封装成方法:**

```js
//num1 num2传入两个值  symbol +-*/符号
function amend(num1,num2,symbol){
  var str1=num1.toString(),str2=num2.toString(),result,str1Length,str2Length
    //解决整数没有小数点方法
    try {str1Length= str1.split('.')[1].length} catch (error) {str1Length=0}
    try {str2Length= str2.split('.')[1].length} catch (error) {str2Length=0}
    // Math.pow(10, 2) 这里表示10的平方
    var step=Math.pow(10,Math.max(str1Length,str2Length))
    // 
    console.log(step);
    switch (symbol) {
        case "+":
            result= (num1*step+num2*step)/step
            break;
        case "-":
            result= (num1*step-num2*step)/step
            break;
        case "*":
            result= ((num1*step)*(num2*step)) / step / step
            break;
        case "/":
            result= (num1*step)/(num2*step)
            break;
        default:
            break;
    }
    return result
    
}
console.log(amend(0.1,0.2,"+"));
```

## 7. 作用域和作用域链

作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离
变量，不同作用域下同名变量不会有冲突。

有哪些：**全局作用域**、**局部（函数）作用域**、**块级作用域**

1. ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。
2. ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现

**什么是作用域链？**

作用域链本质上是底层的变量查找机制。

在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。

总结：

1. 嵌套关系的作用域串联起来形成了作用域链
2. 相同作用域链中按着从小到大的规则查找变量
3. 子作用域能够访问父级作用域，父级作用域无法访问子级作用域

- 当代码在一个环境中执行时，会创建变量对象的一个作用域链

- 由子级作用域返回父级作用域中寻找变量，就叫做作用域链

- 作用域链中的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自中的最后一个对象

- 作用域链前端始终都是当前执行的代码所在环境的变量对象，如果环境是函数，则将其活动对象作为变量对象

**如何延长作用域链？**

执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除，具体来说就是执行这两个语句时，作用域链都会得到加强

1. try - catch 语句的 catch 块；会创建一个新的变量对象，包含的是被抛出的错误对象的声明

2. with 语句。with 语句会将指定的对象添加到作用域链中

## 8. map 和 forEach 的区别？

**相同点：**

1. 都是循环遍历数组中的每一项
2. 每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），
   arr（原数组）
3. 匿名函数中的this都是指向window
4. 只能遍历数组

**不同点：**

1. map()会分配内存空间存储新数组并返回，forEach()不会返回数据。
2. forEach()允许callback（回调）更改原始数组的元素。map()返回的是新的数组。

## 9. js遍历对象的方法？

1. `for...in` 循环
2. `Object.keys()` 方法   获取对象中所有的键  对应 object.value
3. `Object.entries()` 方法

```js
const obj = {  
  foo: 'bar',  
  baz: 42  
};  
  
const entries = Object.entries(obj);  
  
console.log(entries);  
// 输出：[['foo', 'bar'], ['baz', 42]] 二维数组

```

## 10. new操作符具体干了什么呢?

1. 创建一个新的空对象。

2. 将这个新对象的原型指向构造函数的原型。

3. 将构造函数的this指向这个新对象。

4. 执行构造函数中的代码，初始化这个新对象。

5. 返回这个新对象。

## 11.伪（类）数组转换为数组

- **使用 Array.from()**

```js
let pseudoArray = {0: 'a', 1: 'b', 2: 'c', length: 3};  
let realArray = Array.from(pseudoArray);  
console.log(realArray); // 输出: ['a', 'b', 'c']
```

- **使用 Array.prototype.slice.call()**

```js
let pseudoArray = {0: 'a', 1: 'b', 2: 'c', length: 3};  
let realArray = Array.prototype.slice.call(pseudoArray);  
console.log(realArray); // 输出: ['a', 'b', 'c']
```

- **使用 Array.prototype.map.call() 进行属性遍历并组成新的数组**

```js
let pseudoArray = {0: 'a', 1: 'b', 2: 'c', length: 3};  
let realArray = Array.prototype.map.call(pseudoArray, function(item, index) {  
    return item;  
});  
console.log(realArray); // 输出: ['a', 'b', 'c']
```

- **使用 展开运算符**

扩展运算符调用的是**遍历器接口**，如果一个对象没有部署此接口就无法完成转换。

```js
const arrayLike = {
    0: '1',
    1: '2',
    length: 2
}
// Uncaught TypeError: arrayLike is not iterable (arrayLike不可迭代)
console.log([...arrayLike]) // ["1", "2"]
```

### 数组和伪数组的区别?

1. 定义

- 数组是一个特殊对象,与常规对象的区别：
  - 当由新元素添加到列表中时，自动更新length属性
  - 设置length属性，可以截断数组
  - 从Array.prototype中继承了方法
  - 属性为'Array'
- 伪数组是一个拥有length属性，并且他属性为非负整数的普通对象，伪数组不能直接调用数组方法。

2. 区别
   本质：伪数组数组是简单对象，它的原型关系与数组不同

## 12.简单说说 js 中有哪几种内存泄露的情况

1. 意外的全局变量；
2. 闭包；
3. 未被清空的定时器；
4. 未被销毁的事件监听；
5. DOM 引用；

### 闭包一定会造成内存泄漏吗？

在一般情况下，只要正确使用闭包，避免长期占用内存，就不会导致内存泄漏。

## 13. promise和 async await 区别?

**概念**
Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强
大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件结果，而
这些结果一旦生成是无法改变的
async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执
行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象
**两者的区别**

1. Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向
   发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async
   await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同
   于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。
2. async await与Promise一样，是非阻塞的。
3. async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函
   数。

## 14. defer和async区别?

- `defer`要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行。多个defer脚本会按照它们在页面出现的顺序加载。==“渲染完再执行”==
- `async`一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个async脚本是不能保证加载顺序的。==“下载完就执行”==

**延迟加载有哪些js方式？**

1. **defer** : 等 html 全部解析完成，才会执行 js 代码，顺次执行 js 代码。
2. **async**：async 和 html 解析是同步的（一起的），不是顺次执行 js 脚本（谁先加载完谁先执行）

## 15. 同步和异步

### 同步

- 指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。
- 也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序
  和任务排列顺序是一致的。

### 异步

- 异步任务是指不进入主线程，而进入 任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。
- 每一个任务有一个或多个 回调函数。前一个任务结束后，不是执行后一个任务,而是执行回调函数，后一个任务则是不等前一个任务结束就执行。
- 程序的执行顺序和任务的排列顺序是不一致的，异步的。
- 我们常用的setTimeout和setInterval函数，Ajax都是异步操作。

## Ajax

Ajax（Asynchronous JavaScript and XML）是一种创建交互式、快速动态网页应用的网页开发技术，它无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，可以使网页实现异步更新。这意味着可以在不重新加载整个页面的情况下，对页面的某部分进行更新。

Ajax 的核心特性包括：

1. **异步通信**：Ajax 使用异步 HTTP（Asynchronous HTTP）请求，这意味着它可以在不阻塞用户界面的情况下与服务器进行通信。
2. **局部更新**：Ajax 允许只更新页面的某一部分，而不是重新加载整个页面。这可以提高用户体验，减少带宽使用，并使应用更加响应迅速。
3. **无刷新**：由于 Ajax 请求是在后台进行的，用户不会看到浏览器传统的刷新或跳转行为。
4. **数据格式**：虽然 Ajax 的名字中包含“XML”，但现在更常见的是使用 JSON（JavaScript Object Notation）作为数据交换格式，因为它更小、更快且更易于在 JavaScript 中处理。

**由于 Ajax 包含众多特性，优势与不足也非常明显。优势主要以下几点：**

 1.不需要插件支持（一般浏览器且默认开启 JavaScript 即可）；

 2.用户体验极佳（不刷新页面即可获取可更新的数据）；

3.提升 Web 程序的性能（在传递数据方面做到按需放松，不必整体提交）；

4.减轻服务器和带宽的负担（将服务器的一些操作转移到客户端）；

**而 Ajax 的不足由以下几点：**

1.不同版本的浏览器度 XMLHttpRequest 对象支持度不足(比如 IE5 之前)；

 2.前进、后退的功能被破坏（因为 Ajax 永远在当前页，不会几率前后页面）；

 3.搜索引擎的支持度不够（因为数据都不在⻚⾯上，搜索引擎搜索不到）；

 4.开发调试工具缺乏（相对于其他语言的工具集来说，JS 或 Ajax 调试开发少的可怜）。

使用 Ajax 的基本步骤通常包括：

1. **创建 XMLHttpRequest 对象**：这是用于发起 HTTP 请求的对象。
2. **设置请求**：指定请求类型（GET 或 POST）、URL 和其他可能的请求头。
3. **发送请求**：调用 XMLHttpRequest 对象的 `send` 方法。
4. **处理响应**：设置回调函数以处理服务器的响应，这通常包括更新页面的某一部分。

## XML与JSON的区别？

1. 数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。
2. 数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
3. 数据描述方面。JSON对数据的描述性比XML较差。
4. 传输速度方面。JSON的速度要远远快于XML。

## 16. null 和 undefined 的区别

**1. undefined（未定义）**:

- 当你声明一个变量但没有初始化时，该变量的值是`undefined`。
- 函数中没有返回值时，默认返回`undefined`。
- 对象属性没有赋值时，该属性的值是`undefined`。
- 函数参数没有传递值时，参数的默认值是`undefined`

**2. null（空值）**:

- `null`通常是程序员主动赋予变量的一种值，表示该变量被明确地设置为“空”或“不存在”。
- 当你想要表示一个空对象时，可以将其赋值为`null`。
- `undefined`通常表示缺少值，而`null`通常表示被故意设置为空

## 17. call appy bind的作用和区别？

**作用：**

都可以改变函数内部的this指向（第一个参数是指定this指向对象）

**区别点：**

1. call、apply 、bind都是 JavaScript 中用于改变函数执行上下文（即 this 指向）的方法。
2. call 和 apply 的作用是一样的，都是用来调用函数并且改变函数内部的 this 指向。区别在于传参的方式不同，call 的参数是一个一个传递的，而 apply 的参数是以数组的形式传递的。
3. bind 方法不会立即执行函数，而是返回一个新的函数，这个新的函数的 this 值被绑定到了指定的对象，调用时也可以传入参数。同时使用 bind 方法可以实现柯里化，即将函数转化为接收部分参数的函数。

**call：**

```js
var person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}
var person1 = {
  firstName:"John",
  lastName: "Doe"
}
person.fullName.call(person1, "Oslo", "Norway"); //返回结果为：'John Doe,Oslo,Norway'
```

**apply：**

```js
var person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}
var person1 = {
  firstName:"John",
  lastName: "Doe"
}
person.fullName.apply(person1, ["Oslo", "Norway"]); //返回结果为：'John Doe,Oslo,Norway'
```

**bind：**

1. 绑定 `this` 值

```js
const obj = {
  name: 'Alice',
  sayHello() {
    console.log(`Hello, my name is ${this.name}.`)
  }
}

// 调用 obj.sayHello()，输出：Hello, my name is Alice.
obj.sayHello();

// 将 obj.sayHello() 绑定到全局对象上
const globalSayHello = obj.sayHello;
globalSayHello(); // 输出：Hello, my name is undefined.

// 使用 bind 将 obj.sayHello() 绑定回 obj 上
const boundSayHello = obj.sayHello.bind(obj);
boundSayHello(); // 输出：Hello, my name is Alice.

```

2. 绑定参数（柯里化）

```js
function add(a, b,c) {
  return a + b + c;
}

// 使用 bind 预先绑定 a=1，b=2，这样调用函数时只需要传入一个参数 c
const add2 = add.bind(null, 1, 2);
console.log(add2(3)); // 输出：6
```

应用场景

1. object.prototype.toString.call()  检测数据类型
2. apply 经常·数组有关系，比如借助于数学对象实现数组的最大值最小值

```js
let numbers = [1, 2, 3, 4, 5];  

// 使用 apply 和 Math.max 找出数组中的最大值  
let max = Math.max.apply(null, numbers);  
console.log(max); // 输出: 5  

// 使用 apply 和 Math.min 找出数组中的最小值  
let min = Math.min.apply(null, numbers);  
console.log(min); // 输出: 1


```

3. bind：比如改变定时器内部 的this 指向

假设你有一个对象，它有一个定时器，你希望在定时器执行时，`this` 指向这个对象。由于定时器回调函数中的 `this` 通常指向全局对象（在浏览器中是 `window`），所以你需要使用 `bind` 来确保 `this` 指向正确的对象。

```js
const myObject = {
  myProperty: 'Hello, World!',
  myMethod: function() {
    console.log(this.myProperty);
  }
};
// 创建一个定时器，1秒后执行myObject的myMethod方法，并将myMethod内的this绑定到myObject*
setTimeout(myObject.myMethod.bind(myObject), 1000);
```

## 18. this指向（普通函数、箭头函数）

this关键字在JavaScript中表示当前执行上下文的对象。

1. 谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁
2. 匿名函数中的this：匿名函数的执行具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象

### 箭头函数中的this

- 箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的
- 箭头函数中的this指向父级作用域的执行上下文；
- 箭头函数无法使用call、apply、bind方法改变this指向，因为其this值在函数定义的时候就被确定下来

## 19. 继承

继承一些属性，构造的过程和方法

### 继承的好处

a：提高了代码的复用性

b：提高了代码的维护性

c：让类与类之间产生了关系，是多态的前提

### 继承的弊端

类的耦合性增强了,但是开发的原则：高内聚，低耦合

1. 构造函数继承
2. 原型链继承
3. 原型式继承
4. 组合继承
5. 寄生式继承
6. 寄生组合式继承
7. class extends 继承

## 20. promise

promise的设计之初就是为了解决地狱回调的问题的。

本意是承诺，**这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了**

### Promise的三种状态

- Pending----Promise对象实例创建时候的初始状态

- Fulfilled----可以理解为成功的状态
- Rejected----可以理解为失败的状态

```js
let p = new Promise((resolve, reject) => {
    reject('reject')
    resolve('success')//无效代码不会执行
})
p.then( value => {
    console.log(value)
},
reason => {
 console.log(reason)//reject
})
```

当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的

```js
new Promise((resolve, reject) => {
    console.log('1')
    resolve('success')
})
console.log('2')
```

promise的链式调用

如果上一个.then中返回一个新的promise对象，则可以交给下一个.then继续处理。

- 每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)
- 如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调
- 如果then中出现异常,会走下一个then的失败回调
- 在 then中使用了return，那么 return 的值会被Promise.resolve() 包装
- catch 会捕获到没有捕获的异常

```js
Promise.resolve(1)
.then(res => {
console.log(res)
return 2 //包装成 Promise.resolve(2)
})
.catch(err => 3)
.then(res => console.log(res))

ajax(url).then(res => {
 console.log(res)
 return ajax(url1)
}).then(res => {
 console.log(res)
 return ajax(url2)
}).then(res => console.log(res))
```

存在一个缺点：无法取消promise，**错误需要通过回调函数捕获**

场景：

1. 异步请求
2. 定时器
3. 并行异步操作  当需要同时进行多个异步操作，并在它们都完成后执行一些任务时，可以使用 Promise.all 方法。
4. 串行异步操作

### promise静态常用的方法

1. Promise.reject()

```js
new Promise((resolve, reject) => {
 reject()
})
```

2. Promise.resolve()

```jsx
new Promise((resolve, reject) => {
 resolve()
})
```

3. promise.all（[promise1,promise2...]）  等待机制   接收一个 Promise 对象的数组作为参数  会等待所有传入的 Promise 都完成（无论是解析还是拒绝）后，才会执行 `.then` 或 `.catch` 方法。

4. promise.race （[promise1,promise2...]）  赛跑机制   接收一个 Promise 对象的数组作为参数  不会等待所有 Promise 都完成，而是会立即响应第一个解析或拒绝的 Promise。

## 21、JavaScript 内置的常用对象有哪些？

### 对象及方法

Arguments 函数参数集合

Arguments[ ] 函数参数的数组

Arguments 一个函数的参数和其他属性

Arguments.callee 当前正在运行的函数

Arguments.length 传递给函数的参数的个数

### Array 数组

length 属性

join() 将一个数组转成字符串，可以指定分隔符。返回一个字符串。

reverse() 将数组中各元素颠倒顺序

delete 运算符 只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)。

shift() 删除数组中第一个元素，返回删除的那个值，并将长度减 1。

pop() 删除数组中最后一个元素，返回删除的那个值，并将长度减 1。

unshift() 往数组前面添加一个或多个数组元素，长度要改变。arrObj.unshift(“a” ，“b，“c”)

push() 往数组结尾添加一个或多个数组元素，长度要改变。arrObj.push(“a” ，“b”，“c”)

concat( ) 连接数组

slice( ) 截取数组，返回数组的一部分

sort( ) 对数组元素进行排序

splice( ) 插入、删除或替换数组的元素

toLocaleString( ) 把数组转换成局部字符串

toString( ) 将数组转换成一个字符串，不可以指定分隔符

forEach 遍历所有元素

every 判断所有元素是否都符合条件

map 对元素重新组装，生成新数组

filter 过滤符合条件的元素

### String 字符串对象

Length 获取字符串的长度。

toUpperCase() 将字符串中的字母转成全大写。如：strObj.toUpperCase()

charAt(index) 返回指定下标位置的一个字符。如果没有找到，则返回空字符串

substr() 在原始字符串，返回一个子字符串

substring() 在原始字符串，返回一个子字符串

split() 将一个字符串转成数组

charCodeAt( ) 返回字符串中的第 n 个字符的代码

concat( ) 连接字符串

fromCharCode( ) 从字符编码创建—个字符串

indexOf( ) 返回一个子字符串在原始字符串中的索引值(查找顺序从左往右查找)。如果没有找到，则返回-1

lastIndexOf( ) 从后向前检索一个字符串

localeCompare( ) 用本地特定的顺序来比较两个字符串

match( ) 找到一个或多个正则表达式的匹配

replace( ) 替换一个与正则表达式匹配的子串

search( ) 检索与正则表达式相匹配的子串

slice( ) 抽取一个子串

toLocaleLowerCase( ) 把字符串转换小写

toLocaleUpperCase( ) 将字符串转换成大写

toLowerCase( ) 将字符串转换成小写

toString( ) 返回字符串

toUpperCase( ) 将字符串转换成大写

valueOf( )

## 22.谈谈事件委托的理解？

JavaScript 事件代理则是一种简单的技巧，把事件处理器添加到一个上级元素上，这样就避免了把事件处理器添加到多个子级元素

。这主要得益于浏览器的事件冒泡机制。

**优点：**

1、减少事件注册，节省内存。

5、不用在新添加的 li 上绑定 click 事件。

**缺点：**

1、事件委托基于冒泡，对于不冒泡的事件不支持（例如 错误、取消、加载、存储事件）

2、层级过多，冒泡过程中，可能会被某层阻止掉。

### 阻止事件冒泡

1. **给子级加 event.stopPropagation( )**

```js
$("#div1").mousedown(function(e){
    var e=event||window.event;
    event.stopPropagation();
});
```

2. **在事件处理函数中返回 false**

```js
$("#div1").mousedown(function(event){
    var e=e||window.event;
    return false;
});
```

但是这两种方式是有区别的。`return false` 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。`event.stopPropagation()`则只阻止事件往上冒泡，不阻止事件本身。

**3. event.target==event.currentTarget，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；**

### 阻止默认事件

（1）event.preventDefault( )

（2）return false

### 什么叫做默认行为

比如点击a标签会跳转到另个页面，比如拖拽到一张图片到浏览器，浏览器会打开这个图片，比如点击表单提交按钮，会提交当前表单……

怎么做：

```js
<a id="aTag" href="https://baidu.com">点我啊</a>

const aTag = document.getElementById('aTag');
 
aTag.addEventListener('click', function(e) {
    e.preventDefault();    // 阻止a标签默认事件
})
```

## 23.什么是闭包？

++MDN的官方解释：

> 闭包是函数和声明该函数的词法环境的组合

更通俗一点的解释是：

> 内层函数, 引用外层函数上的变量, 就可以形成闭包

**定义：**

 一个作用域可以访问到另外一个函数内部的局部变量，或者说一个函数（子函数）访问另一个函数（父函数）中的变量。此时就会产生闭包，那么这个变量所在的函数我们就称之为闭包函数。

```js
function aaa() {
    let a = 0
    return function() {
        alert(a++)
    }
}

let fun = aaa()
fun()              // 1
```

**优缺点：**

闭包的主要作用：延伸了变量的作用范围，因为闭包函数中的变量不会等着闭包函数执行完就销毁，因为还有别的函数要调用它，只有等着所有的函数都调用完了它才会销毁。 **实现数据的私有。**

优点:

1）可以减少全局变量的定义，避免全局变量的污染

2）能够读取函数内部的变量

3）在内存中维护⼀个变量，可以⽤做缓存

缺点:

1）可能造成内存泄露

2）闭包可能在⽗函数外部，改变⽗函数内部变量的值。

3）造成性能损失

使用场景：

1. 封装私有变量
2. 闭包可以用于创建模块化的代码结构，避免全局变量的污染。
3. 在处理用户输入或频繁触发的事件时，可以通过闭包来实现防抖（debounce）和节流（throttle）的效果。防抖和节流是优化性能和减少不必要请求的常见方法。
4. 缓存数据：通过闭包，可以在函数内部缓存一些计算结果或其他重要数据，避免重复计算或请求。

## 24.for in 和 for of 的区别

1、推荐在循环对象属性的时候使用 for...in，在遍历数组的时候的时候使用 for...of

2、for...in 循环出的是 key，for...of 循环出的是 value

3、注意，for...of 是 ES6 新引入的特性。修复了 ES5 引入的 for...in 的不足

4、for...of 不能循环普通的对象，需要通过和 Object.keys()搭配使用

## 25、split（）和 join（）的区别？

split()是把一串字符（根据某个分隔符）分成若干个元素存放在一个数组里即切割成数组的形式；

join() 是把数组中的字符串连成一个长串，可以大体上认为是 split()的逆操作

## 26.深拷贝

> 首先浅拷贝和深拷贝只针对引用类型

**浅拷⻉:** 拷贝的是地址

1. **object.assign()**

```js
let original = { a: 1, b: 2 };
let copied = Object.assign({}, original);
console.log(copied); // { a: 1, b: 2 }
```

2. **展开运算符**

```js
let original = { a: 1, b: 2 };
let copied = { ...original };
console.log(copied); // { a: 1, b: 2 }
```

3. **使用 slice() 和 concat() 方法**，可以将一个数组拷贝到另一个数组上。

```js
let original = [1, 2, 3];
let copied = original.slice();
console.log(copied); // [1, 2, 3]
```

```js
let original = [1, 2, 3];
let copied = original.concat();
console.log(copied); // [1, 2, 3]
```

如果是简单数据类型拷贝值，不会影响原对象，引用数据类型拷贝的是地址。

**深拷⻉:** 拷贝的是对象，不是地址

1. **递归**
2. **JSON 对象中的 parse 和 stringify**

```js
const originArray = [1,2,3,4,5];
const cloneArray = JSON.parse(JSON.stringify(originArray));
console.log(cloneArray === originArray); // false
```

3. **lodash 库 里的 cloneDeep**

用到？

1. 处理嵌套对象和数组：创建一个独立的副本。这样，对副本的修改不会影响原始数据。
2. 操作不可变的数据
3. 序列化和反序列化：当你需要将对象转换为字符串进行存储或传输时，深拷贝可以帮助你创建一个完整的副本，并且在后续需要时可以还原为原始对象。

## 27.原型链

![image-20240408124953660](images/image-20210306104516852.png)

在 JavaScript 中，除去一部分内建函数，绝大多数的函数都会包含有一个叫做 `prototype` 的属性，指向原型对象。基于构造函数创建出来的实例, 都可以共享访问原型对象的属性。

### 原型

1. 构造函数通过原型分配的函数是所有对象所共享的
2. js 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象。
3. 这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存。
4. 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。
5. 构造函数和原型对象中的this 都指向实例化对象。

### constructor属性

每个原型对象里面都有个 constructor 属性，该属性指向该原型对象的构造函数。

使用场景：

如果有多个对象的方法，我们可以给原型对象采取 对象形式赋值。

但是这样就会覆盖构造函数原型对象原来的内容。

这样修改后的原型对象 constructor 就不再指向当前构造函数了。

此时，我们应该在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。

### 对象原型 --proto--

实例对象的原型，对象都有一个属性 --proto--，指向构造函数的 prototype 原型对象。

之所以我们对象可以使用构造函数prototype原型对象上的方法和属性，就是因为对象有--proto--原型的存在。

### 原型链

所有的实例对象里面都有--proto--对象原型，指向原型对象

所有的原型对象里面有 constructor，指向创造该原型对象的构造函数

1. 当访问一个对象的属性和方法时，首先查找这个对象本身有没有该属性
2. 如果没有就查找它的原型（也就是--proto--指向的prototype原型对象）
3. 如果还没有，就查找原型对象上的原型
4. 依此类推，一直找到为止
5. --proto--对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。
6. 可以使用 instanceof 运算符用于检测构造函数的prototype 属性是否出现在某个实例对象的原型链上。

## 28.防抖和节流

**防抖(debounce)**：指在一定时间内，多次触发同一个事件，只执行最后一次操作。

触发⾼频事件后 n 秒内函数只会执⾏⼀次，如果 n 秒内⾼频事件再次被触发，则重新计算时间

使用场景：

1. 搜索框防抖
1. 手机号、邮箱的输入验证检测

**手写防抖函数：**

思路：防抖的核心就是利用 settimeout 实现的

1. 声明一个定时器变量
2. 当鼠标每次滑动都先判断 是否有定时器了，如果有定时器先清除以前的定时器
3. 如果没有定时器则开启定时器，记得存到变量里面
4. 在定时器里面调用要执行的函数

```js
function debounce(fn,t) {
    let timeId = null
    return function() {
        if(timeId) clearTimeout(timeId)
        timeId = setTimeout(function() {
           fn() 
        },t)
    }
}
box.addEventListener('mousemove',debounce(mouseMove,500))
```

**节流(throttle)**：指在一定时间内，多次触发同一个事件，只执行第一次操作。

⾼频事件触发，但在 n 秒内只会执⾏⼀次，所以节流会稀释函数的执⾏频率

使用场景：

1. 轮播图切换点击效果
2. 页面尺寸缩放resize
3. 滚动条滚动

**手写节流函数：**

思路：一样

1. 声明一个定时器变量
2. 当鼠标每次滑动都先判断 是否有定时器了，如果有定时器，则不开启新定时器
3. 如果没有定时器则开启定时器，记得存到变量里面
4. 定时器里面调用执行的函数
5. 清空定时器

```js
function throttle(fn,t) {
    let timeId = null
    return function() {
        if(!timeId) {
            timeId = setTimeout(function() {
               fn()
                timeId = null
            },t)
        }
    }
}
box.addEventListener('mousemove',throttle(mouseMove,500))
```

区别：防抖动是将多次执⾏变为最后⼀次执⾏，节流是将多次执⾏变成每隔⼀段时间执⾏。

## 29.ES6

1. let  const
2. 模板字符串
3. 箭头函数
4. object.keys() 遍历对象的键
5. object.assign() 合并对象 常用于对象浅拷贝
6. for of
7. import（用于在一个模块中加载另一个含有 export 接口的模块）  export（用于对外输出本模块）
8. promise
9. set
10. class

## 30.介绍下 Set、Map 的区别

**区别：**

应用场景 Set 用于数据重组，Map 用于数据储存

Set：

成员不能重复

只有值没有键名，类似数组

可以遍历，方法有 add, delete,has

Map:

本质上是健值对的集合，类似集合

可以遍历，可以跟各种数据格式转换

## 31.async await

1. async 用于修饰一个函数，表示一个函数是异步的
2. await 要用在 async 函数中
3. await 后面一般会跟一个 promise 对象
4. await 只会等待 promise 成功的结果

## TypeScript

1. **解释TypeScript和JavaScript之间的关系。**
答案：TypeScript是JavaScript的超集，ts是强类型的语言，js是弱类型语言，它添加了静态类型和其他一些特性。TypeScript代码可以编译成JavaScript代码，因此可以在任何支持JavaScript的环境中运行。

2. **TypeScript中的类型注解是什么？如何使用类型注解？**
答案：类型注解是指在变量、函数参数、函数返回值等地方显式地声明类型信息。可以使用冒号（:）后跟类型来添加类型注解。例如：

```js
let num: number = 10;
function add(a: number, b: number): number {
return a + b;
}
```

3. **TypeScript中的接口是什么？如何定义和使用接口？**
答案：接口是一种用于定义对象的结构和类型的语法。可以使用interface关键字来定义接口。例如：

```js
interface Person {
 name: string;
 age: number;
}
function greet(person: Person) {
 console.log(`Hello, ${person.name}!`);
}
let john: Person = { name: "John", age: 25 };
greet(john); // 输出 "Hello, John!"
```

4. **TypeScript中的类是什么？如何定义和使用类？**
答案：类是一种用于创建对象的蓝图，它包含属性和方法。可以使用class关键字来定义类。例如：

```js
class Person {
 name: string;
 age: number;
 constructor(name: string, age: number) {
 this.name = name;
 this.age = age;
}
greet() {
 console.log(`Hello, ${this.name}!`);
}
}
let john = new Person("John", 25);
john.greet(); // 输出 "Hello, John!"
```

5. **TypeScript中的泛型是什么？如何使用泛型？**
答案：泛型是一种用于创建可重用代码的工具，它允许在定义函数、类或接口时使用占位符类型。可以使用尖括号（<>）来指定泛型类型。例如：

```js
function identity<T>(value: T): T {
 return value;
}
let result = identity<string>("Hello");
console.log(result); // 输出 "Hello"
```

6. **TypeScript中的枚举是什么？如何定义和使用枚举？**
答案：枚举是一种用于定义命名常量集合的语法。可以使用enum关键字来定义枚举。例如：

```js
enum Color {
 Red,
 Green,
 Blue,
}
let color: Color = Color.Green;
console.log(color); // 输出 1
```

7. **TypeScript中的模块是什么？如何导出和导入模块？**
答案：模块是用于组织和封装代码的单元。可以使用export关键字将模块中的变量、函数、类等导出，以便其他模块可以使用。可以使用import关键字来导入其他模块的导出。例如：

```js
// module.ts
export function greet(name: string) {
 console.log(`Hello, ${name}!`);
}
// main.ts
import { greet } from "./module";
greet("John"); // 输出 "Hello, John!"
```

8. **TypeScript中的类型推断是什么？如何使用类型推断？**
答案：类型推断是指TypeScript根据上下文自动推断变量的类型，而无需显式地添加类型注解。例如：

```js
let num = 10; // 推断为 number 类型
let str = "Hello"; // 推断为 string 类型
```

9. **TypeScript中的命名空间是什么？如何定义和使用命名空间？**
答案：命名空间是一种用于组织和封装代码的机制，它避免了全局命名冲突。可以使用namespace关键字来定义命名空间。例如：

```js
namespace MyNamespace {
 export function greet(name: string) {
 console.log(`Hello, ${name}!`);
}
}
MyNamespace.greet("John"); // 输出 "Hello, John!"
```

10. **TypeScript中的类型别名是什么？如何定义和使用类型别名？**
答案：类型别名是给类型起一个别名，以便在代码中更方便地引用。可以使用type关键字来定义类型别名。例如：

```js
type Point = { x: number; y: number };
function printPoint(point: Point) {
 console.log(`(${point.x}, ${point.y})`);
}
let p: Point = { x: 1, y: 2 };
printPoint(p); // 输出 "(1, 2)"
```

## 浏览器

## 1.cookie sessionStorage localStorage区别

**共同点：**

都是保存在浏览器端、且同源的

**区别：**

1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下

2. 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大

3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭

4. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的

5. web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
6. Storage的api接口使用更方便

| 方式名称       | 标准说明     | 功能说明                                                     |
| -------------- | ------------ | ------------------------------------------------------------ |
| Cookie         | HTML5 前加入 | 1.会为每个请求自动携带所有的Cookie数据，比较方便，但是也是缺点，浪费流量；<br />2.每个domain(站点)限制存储20个cookie；<br/>3.容量只有4K<br/>4.浏览器API比较原始，需要自行封装操作。 (js-cookie) |
| localStorage   | HTML5 加入   | 1.兼容IE8+，操作方便；<br/>2.永久存储，除非手动删除；<br/>3.容量为5M |
| sessionStorage | HTML5 加入   | 1.功能基本与 localStorage 相似，但当前页面关闭后即被自动清理；<br/>2.与Cookies、localStorage 不同点是不能在所有同源窗口间共享，属于会话级别的存储 |
| Web SQL        | 非标准功能   | 1.2010年已被废弃，但一些主流浏览器中都有相关的实现；<br/>2.类似于 SQLite 数据库，是一种真正意义上的关系型数据库，⽤SQL进⾏操作； |
| IndexedDB      | HTML5 加入   | 1.是一种 NoSQL 数据库，⽤键值对进⾏储存，可进⾏快速读取操作；<br/>2.适合复杂 Web存储场景，⽤JS操作⽅便 (前端大量存数据的场景较少, 如果有, 可以用) <br />3.存储空间容量, 大于等于 250MB，甚至没有上限 |

## 2. 浏览器输入URL发生了什么

1. URL 解析
2. DNS 查询
3. TCP 连接
4. 处理请求
5. 接受响应
6. 渲染页面

## 3. 浏览器是如何渲染页面的？

不同浏览器内核渲染机制有所区别

1. HTML 被 HTML 解析器解析成 DOM 树；
2. CSS 被 CSS 解析器解析成 CSSOM 树；
3. 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；
4. 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
5. 将布局绘制(paint)在屏幕上，显示出整个页面。

## 4. 重绘、重排

**概念：**

1. 重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树
2. 重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等

**区别：**

重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）

**引发重排：**

1. 添加、删除可见的dom
2. 元素的位置改变
3. 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)
4. 页面渲染初始化
5. 浏览器窗口尺寸改变
6. 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存

**优化方案：**

浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘

减少 reflow/repaint：

1. 不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的className。

2. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。

3. 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会reflow 的。

4. 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)

5. 不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）

## 5. 事件循环（Event loop）

js执行主线程代码是一行一行往下执行的，js是单线程的，所以遇到异步任务，他会将异步任务交给浏览器，浏览器是多线程的，可以处理多件事情，如果满足条件就会将需要执行的内容放到任务队列中，只有主线程空闲了，才会执行任务队列的代码。主线程从"任务队列"中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环

事件循环的工作方式可以概括如下：

1. 先执行同步代码，
2. 遇到异步宏任务则将异步宏任务放入宏任务队列中，
3. 遇到异步微任务则将异步微任务放入微任务队列中，
4. 当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，
5. 微任务执行完毕后再将异步宏任务从队列中调入主线程执行，
6. 一直循环直至所有任务执行完毕。

为了防止某个耗时任务导致程序假死的问题，异步代码由js 委托给宿主环境（浏览器、node环境）等待执行。

**JavaScript 的事件分两种：**

1. 宏任务：包括整体代码 script，setTimeout，setInterval
2. 微任务：Promise的回调函数（如then、catch、finally中的代码）

## 6. 跨域

**跨域是什么？**

跨域（Cross-Origin）指的是在浏览器中，当一个请求的源（Origin）与目标资源的源不一致时，即发生跨域访问。在默认情况下，浏览器的同源策略（Same-Origin Policy）会阻止这种跨域访问。同源策略是为了保护用户的信息安全，防止恶意网站对其他网站的资源进行访问和操作。

**同源策略规定几个约束：**

1. 协议相同
1. 域名相同
1. 端口号相同

**同源策略限制内容有：**

- cookie、localstorage、indexedDB 等
- dom节点
- ajax 请求

**跨域解决⽅法：**

1、jsonp⽅式

2、代理服务器的⽅式

3、服务端允许跨域访问(CORS)

4、取消浏览器的跨域限制

## 7.常见code码

1. 200 - 请求成功。
2. 301 - 永久重定向。
3. 302 - 临时重定向。
4. 304 - 未修改。
5. 400 - 请求错误。
6. 401 - 未授权。
7. 403 - 禁止访问。
8. 404 - 资源不存在。
9. 500 - 服务器错误。
10. 503 - 服务不可用。

## 8. http 和 https 的区别

1. **安全性：**
   - **HTTP：** 数据以纯文本形式传输，不进行加密。这使得HTTP在传输过程中容易受到窃听和中间人攻击的威胁。因此，不建议在处理敏感信息（如信用卡号、登录凭据等）的网页上使用纯HTTP。
   - **HTTPS：** 数据通过使用TLS/SSL协议进行加密，因此更加安全。加密的数据传输使得窃听者很难理解或篡改传输的数据。

2. **协议：**
   - **HTTP：** 使用的是标准的HTTP协议。
   - **HTTPS：** 在HTTP的基础上添加了TLS/SSL协议，通过在传输层对数据进行加密和身份验证来提供安全性。
3. **默认端口：**
   - **HTTP：** 默认端口是80。
   - **HTTPS：** 默认端口是443。
4. **证书：**
   - **HTTP：** 不需要证书。
   - **HTTPS：** 需要使用SSL证书，用于在客户端和服务器之间建立安全连接。证书通过第三方机构（Certificate Authorities）颁发，用于验证网站的身份。
5. **搜索引擎排名：**
   - **HTTP：** 某些搜索引擎可能更喜欢HTTPS网站，因为它们提供更安全的用户体验。
   - **HTTPS：** 使用HTTPS的网站在搜索引擎排名中可能会得到一些额外的优势。

## 9. 前端优化策略

1、减少http请求数

2、将脚本往后挪，减少对并发下载的影响

3、避免频繁的DOM操作

4、压缩图⽚

5、gzip压缩优化，对传输资源进⾏体积压缩(html,js,css)

6、按需加载

7、组件化

8、减少不必要的Cookie（Cookie在客户端，伴随着HTTP请求在浏览器和服务器之间传递，由于cookie在访问对应域名下的资源时都会通过HTTP请求发送到服务器，从⽽会影响加载速度，所以尽量减少不必要的Cookie。）

## 10.介绍一下 websocket

它是建立于单个TCP连接上的全双工通信协议，允许客户端和服务端进行实时数据传输

websocket 是一种网络通信协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通 信的协议，这个对比着 HTTP 协议来说，HTTP 协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。HTTP 协议无法实现服务器主动向客户端发起消息，websocket 连接允许客户端和服务器之间进行全双工通信， 以 便 任一方都可以通过建立的连接将数据推送到另一端。websocket 只需要建立一次连接， 就 可 以一直保持连接状态

## 11.webpack

Webpack是一个静态模块打包工具，用于分析、压缩和打包代码

Webpack配置文件通常是一个名为webpack.config.js的JavaScript文件

Webpack的核心概念：

1. 入口(entry)：指定Webpack编译的入口文件。
2. 输出(output)：指定编译后文件的输出位置和名称。
3. 加载器(loader)：将非JavaScript文件（如CSS，图片等）转换为Webpack可以处理的模块。
4. 插件(plugin)：用于实现Webpack的各种功能，如打包优化、资源管理和环境变量注入等。
5. mode（模式）：可以选择生产环境（production）或开发环境（development）或者 none 之
   中的一个。不同模式会加载不同的配置。

**常用loader**
css-loader读取 合并CSS 文件
style-loader把 CSS 内容注入到 JavaScript 里
sass-loader 解析sass文件（安装sass-loader，node-sass）
postcss-loader自动添加浏览器兼容前缀（postcss.config.js配置）

babel-loader 将Es6+ 语法转换为Es5语法

url-loader将文件转换为base64 URI。
vue-loader处理vue文件。

**常见Plugins：**

HtmlWebpackPlugin自动在打包结束后生成html文件，并引入bundle.js
cleanwebPackPlugin打包自动删除上次打包文件

| 名称     | 内容                                                         |
| :------- | :----------------------------------------------------------- |
| 代码转换 | typescript编译成JavaScript、scss编辑成css                    |
| 文件优化 | 压缩JavaScript、css、html、压缩合并图片                      |
| 代码分割 | 提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 |
| 模块合并 | 采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 |
| 自动刷新 | 监听本地源代码的变化，自动构建，刷新浏览器                   |
| 代码校验 | 在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 |
| 自动发布 | 更新完代码后，自动构建出线上发布代码并传输给发布系统         |

### webpack和vite的区别

**1.开发模式不同：**

Webpack在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而Vite则采用了基于ES Module的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。

**2.打包效率不同：**

Webpack在打包时，会把所有的模块打包成一个bundle，这会导致初次加载速度较慢；而Vite则利用了浏览器对ES Module的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。

**3.插件生态不同：**

Webpack的插件生态非常丰富，有大量社区和官方插件可以选择，覆盖了前端开发的各个方面；而Vite的插件生态尽管在不断发展，但相比Webpack来说还显得较为稀少。

**4.配置复杂度不同：**

Webpack的配置相对复杂，对新手不够友好；而Vite在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。

**5.热更新机制不同：**

Webpack的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite的热更新则只会针对改动的模块进行更新，提高了更新速度

## **12.Get 和 Post 的区别以及使用场景**

|                  | GET方法                                                      | POST方法                                     |
| ---------------- | ------------------------------------------------------------ | -------------------------------------------- |
| **数据传输⽅式** | 通过URL传输数据 (地址栏拼接参数)                             | 通过请求体传输                               |
| **数据安全**     | 数据暴露在URL中，可通过浏览历史记录、缓存等很容易查到数据信息 | 数据因为在请求主体内，所以有⼀定的安全性保证 |
| **数据类型**     | 只允许 ASCII 字符                                            | ⽆限制                                       |
| **GET⽆害**      | 刷新、后退等浏览器操作是⽆害的                               | 可能会引起重复提交表单                       |
| **功能特性**     | 安全且幂等（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化。<br />**幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）** | ⾮安全(会引起服务器端的变化)、**⾮幂等**     |

**还有语义的区别：**

GET 是获取， POST 是提交

Get 是用来从服务器上获得数据，而 post 是用来向服务器上传递数据

## 13. HTTP有哪些⽅法？

HTTP 1.0 标准中，定义了3种请求⽅法：GET、POST、HEAD

HTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT

## 14. 各个HTTP方法的具体作用是什么？

|  方法   | 功能                                                         |
| :-----: | ------------------------------------------------------------ |
|   GET   | 通常⽤于请求服务器发送某些资源                               |
|  POST   | 发送数据给服务器                                             |
|  HEAD   | 请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。<br />该请求⽅法的⼀个`使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源` |
|   PUT   | ⽤于全量修改⽬标资源 (看接口, 也可以用于添加)                |
| DELETE  | ⽤于删除指定的资源                                           |
| OPTIONS | ⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全) |
|  TRACE  | 该方法会  让服务器  原样返回任意客户端请求的信息内容, 用于诊断和判断 |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器<br />(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户) |
|  PATCH  | ⽤于对资源进⾏部分修改                                       |

GET POST PUT PATCH DELETE

GET/DELETE  参数是在地址栏中传递的

PUT/PATCH/POST 参数是在请求体传递的

## 11. http缓存控制

### 11.1 基本认知

**Web 服务缓存** 大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 服务器缓存）、浏览器缓存。

**浏览器缓存** 也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。**`这里我们只讨论 HTTP 缓存相关内容`。**

**HTTP缓存**:  (优化页面加载的效率, 如果没有缓存策略, 每次重新加载页面, 会非常慢!)

- **强缓存**
- **协商缓存**

在具体了解 HTTP 缓存之前先来明确几个术语：

- 缓存命中率：从缓存中得到数据的请求数  与    所有请求数的比率。理想状态是越高越好。

  (看所有的请求中, 多少从缓存中读的)

- 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。

- 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。

- 失效：失效就是把内容从缓存中移除。

**浏览器缓存主要是 HTTP 协议定义的缓存机制。**

### 浏览器缓存, HTTP缓存分类

浏览器缓存分为`强缓存`和 `协商缓存`，浏览器加载一个页面的简单流程如下：

1. 浏览器先根据这个资源的  **http头信息**  来 **判断是否命中强缓存**。

   如果命中则直接加载在缓存中的资源，并不会将请求发送到服务器。（强缓存）

2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。

   服务器来判断浏览器本地缓存是否失效。

   若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）

3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）

### 11.2 强缓存  (验证缓存是否过期)

**(进行判断缓存是否有效,  就是判断资源是否过期, 如果未过期, 直接用缓存)**

**强缓存**

命中强缓存时，浏览器并不会将请求发送给服务器。

在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。

![img](images/940884-20180423141536107-329179455.png)

强缓存是利用http的返回的响应头中的Expires或者Cache-Control (优先级更高) 两个字段来控制的，用来表示资源的缓存时间。

Expires: 指定一个具体时间(2020年12月12日 17:00), 到了这个时间了, 缓存过期了, 在时间内, 都是有效的, 可以直接读

Cache-Control : 指定一个过期时间 (3600s), 这个资源你加载到后, 可以用 3600s

**Expires：**

缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。

Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

![image-20210308182724715](images/image-20210308182724715.png)

该字段会返回一个时间，比如Expires:  Wed, 23 Nov 2050 16:00:01 GMT 。这个时间代表着这个资源的失效时间，也就是说在xx年xx月xx日时间之前都是有效的，即命中缓存。

这种方式有一个明显的缺点，由于失效时间是一个`绝对时间`，所以当 **服务器与客户端 时间偏差很大**  以后，就会导致缓存混乱。于是发展出了Cache-Control。

**Cache-Control：**

Cache-Control是一个`相对时间`，例如Cache-Control:max-age 3600，代表着资源的有效期是3600秒。

由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。

Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。

Cache-Control 可以由多个字段组合而成，主要有以下几个取值：

1. **max-age** 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。

   例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 / 60）天，

   第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。

   ![image-20210308182737673](images/image-20210308182737673.png)

   在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。

2. **no-cache** 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证的请求到服务器, 问服务器是否可以读缓存。

   不是字面意思上的不缓存。

3. **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。

注意: 如果命中强缓存,  在有效期内, 使用了本地浏览器的缓存,  请求该资源是不会向服务器发送请求的! (大大减轻了服务器压力)

### 11.3 协商缓存 (强缓存未命中-发送请求进行协商)

看看过期时间, 食品没过期, 直接吃 (直接读缓存, 不发请求)    命中强缓存!

食品过期时间过了,  能不能吃呢?  问问专家(服务器),  专家瞅了一眼,  还能吃, 不会死人, 重新标了个过期时间(有科学依据)

 (响应304, 不返回内容) , 可以用 (协商缓存)

如果问过专家(服务器), 专家瞅了一眼, 呀真不能用了, 原来的不要了, 我重新给你发一个 (响应200, 并返回内容)

**协商缓存：**

若未命中强缓存(强缓存过期了)，则浏览器会将请求发送至服务器。

服务器根据http头信息中的`Last-Modify/If-Modify-Since`或`Etag/If-None-Match`来判断是否命中协商缓存。

如果命中，则http返回码为304 (你本地之前加载的资源是有效的)，浏览器从缓存中加载资源。

**Last-Modify/If-Modify-Since：**

浏览器第一次请求一个资源的时候, 服务器返回的header中会加上Last-Modify，

Last-modify是一个时间标识该资源的**最后修改时间**，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。

![image-20210308182821236](images/image-20210308182821236.png)

当浏览器再次请求该资源时(进行协商请求时)，发送的请求头中会包含If-Modify-Since，**该值为缓存之前返回的Last-Modify**。

服务器收到If-Modify-Since后，根据实际服务器的资源的最后修改时间, 进行判断是否命中缓存。

![img](images/940884-20180423141732879-1484228353.png)

如果命中缓存，则返回 **http304**，并且不会返回资源内容，并且不会返回Last-Modify。

![image-20210308123308326](images/image-20210308123308326.png)

由于对比的是**服务端的修改时间**，所以就算客户端与服务端时间差距,  也不会有问题。

**但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。**

比如: 最后修改只能精确到秒级, 一秒进行了多次修改, 就不行了,  **于是出现了ETag/If-None-Match。**

**ETag/If-None-Match：**

与Last-Modify/If-Modify-Since (最后修改时间)不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。

ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。

ETag值的变更则说明资源状态已经被修改。

服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。

![image-20210308182858733](images/image-20210308182858733.png)

ETag生成靠以下几种因子

1. 文件的i-node编号，是Linux/Unix用来识别文件的编号。

2. 文件最后修改时间

3. 文件大小

   ...

**生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。生成一个标记文件的唯一值**

**既生 Last-Modified 何生 Etag ？**

你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？

Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

1. Last-Modified标注的最后修改只能精确到秒级

   如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间

2. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加 **准确的控制缓存。**

不会仅仅只根据最后的修改时间判断是否进行使用缓存

Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，

最后才决定是否返回304。

小结:

- **强缓存:** 检查过期时间, 判断缓存是否失效,  如果不失效, 直接用, 不发请求

  大大的减少了 服务器的请求次数, 在过期时间内, 直接从客户端内存中读

- **协商缓存**: 强缓存命中失效了, 超过过期时间了, 拿着标识(最后的修改时间,  唯一标识etag), 去问服务器, 是否真的过期了

  如果验证通过,  服务器会直接响应 304, 且不会返回资源

不太会变的资源 => 图片, 非常的适合应用强缓存 (过期时间也可以设置的很长)

如果是一些很可能会变的资源, 也希望能缓存 => 过期时间设置短一些,  一旦过期, 协商缓存

实际工作两者相互配合

## Vue

## 1.谈谈你对 Vue 生命周期的理解？

**（1）生命周期是什么？**

Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期

**（2）各个生命周期的作用**

| beforeCreate | 组件实例创建之前，组件实例被创建之初，组件的属性生效之前     |
| :------------ | :----------------------------------------------------------- |
| created       | 组件实例创建完成之后，组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，\$el 还不可用 |
| beforeMount   | 组件挂载开始之前，在挂载开始之前被调用：相关的 render 函数首次被调用 |
| mounted       | 组件挂载开始之后，el 被新创建的 vm.\$el 替换，并挂载到实例上去之后调用该钩子 |
| beforeUpdate  | 组件数据更新之前，组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 |
| updated       | 组件数据更新之后                                             |
| activited     | 组件被激活时，keep-alive 专属，组件被激活时调用，只有当组件被`<keep-alive>`包裹时，`activated`和`deactivated`才会被触发。 |
| deactivated | 组件失活时，keep-alive 专属，组件被销毁时调用，只有当组件被`<keep-alive>`包裹时，`activated`和`deactivated`才会被触发。 |
| beforeDestory | 组件销毁前调用                                               |
| destoryed     | 组件销毁后调用                                               |

## vue2和vue3的区别

| vue2          | vue3                  | 差异比较                                                     |
| ------------- | :-------------------- | :----------------------------------------------------------- |
| beforeCreate  | **setup**             | setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method |
| created       | **setup**             |                                                              |
| beforeMount   | onBeforeMount         | 组件挂载到节点上之前执行的函数                               |
| mounted       | onMounted             | 组件挂载完成后执行的函数                                     |
| beforeUpdate  | onBeforeUpdate        | 组件更新之前执行的函数                                       |
| updated       | onUpdated             | 组件更新完成之后执行的函数                                   |
| beforeDestroy | **onBeforeUnmount**   | 卸载之前执行的函数，相比改名了                               |
| destroyed     | **onUnmounted**       | 卸载之后执行的函数                                           |
| activated     | onActivated           | 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行   |
| deactivated   | onDeactivated         | 比如从 A 组件，切换到 B 组件，A 组件消失时执行。失活时执行   |
| errorCaptured | onErrorCaptured       | 当捕获一个来自子孙组件的异常时激活钩子函数                   |
|               | **onRenderTracked**   | vue3新增的周期用于开发调试使用的，会在渲染周期中追踪依赖项   |
|               | **onRenderTriggered** | vue3新增的周期用于开发调试使用的，会在依赖项被触发时被调用   |

## 2. keep-alive

**1、什么是keep-alive？**

keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，⽽不是销毁它们。keep-alive 是⼀个抽象组件：它⾃身不会渲染成⼀个 DOM 元素，也不会出现在⽗组件链中

**2、keep-alive的优点**？

在组件切换过程中 把切换出去的组件保留在内存中，防⽌重复渲染DOM，减少加载时间及性能消耗，提⾼⽤户的体验。

3. **keep-alive有三个属性**

include ： 只有匹配的组件会被缓存

exclude ： 任何匹配的组件都不会被缓存

max ： 最多可以缓存多少组件实例

**4、keep-alive的使⽤会触发两个⽣命周期函数？**

这两个函数分别是

activated 当组件被激活（使⽤）的时候触发 可以简单理解为进⼊这个⻚⾯的时候触发

deactivated 当组件不被使⽤的时候触发 可以简单理解为离开这个⻚⾯的时候触发

## 3. 数据双向绑定原理

数据变化更新视图

- 输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。
- Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化

vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的⽅式来实现的.

 数据劫持、vue是通过Object.defineProperty()来实现数据劫持，

 其中会有getter()和setter⽅法；当读取属性值时，就会触发getter()⽅法，

 在view中如果数据发⽣了变化，就会通过Object.defineProperty( )对属性设置⼀个setter函数，

 当数据改变了就会来触发这个函数；

实现一个监听器 ->实现一个解析器 -> 实现一个订阅者 -> 实现一个订阅器 Dep

## 说说vue中的diff算法？

diff算法 当data发生改变 会根据新的数据生成一个新的虚拟dom ，新的虚拟dom和旧的虚拟dom进行对比，这个对比的过程就是diff算法。

Vue2 是全量 Diff（当数据发生变化，它就会新生成一个DOM树，并和之前的DOM树进行比较，找到不同的节点然后更新。）；Vue3 是静态标记 + 非全量 Diff（Vue 3在创建虚拟DOM树的时候，会根据DOM中的内容会不会发生变化，添加一个静态标记。之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。）

使用最长递增子序列优化对比流程，可以最大程度的减少 DOM 的移动，达到最少的 DOM 操作

## v-model的使用？

v-model实现双向绑定的语法糖，常用于表单与组件之间的数据双向绑定.

v-model绑定在组件上的时候做了以下步骤

- 在父组件内给子组件标签添加 v-model ，其实就是给子组件绑定了 value 属性
- 子组件内使用 props 创建 创建 value 属性可以拿到父组件传递下来的值，名字必须是 value。
- 子组件内部更改 value 的时候，必须通过 $emit 派发一个 input 事件，并携最新的值
- v-model 会自动监听 input 事件，把接收到的最新的值同步赋值到 v-model 绑定的变量上

**vue2版本的v-model：**

父组件：

此时，v-model="visible"  等价于 :show="visible" 加上 @change="visible = $event"

```js
<Chlid v-model="visible" />
 
<script>
export default {
   data() {
    return {
      visible: true,
    }
   }
}
<script/>
```

子组件，默认写法：

```js
<template>
    <div v-show="value">
        我是子组件文字
        <button @click="$emit('input',false)">关闭</button>
    </div>
</template>
 
<script>
export default {
    props: {
        value: {
            type: Boolean,
            default: false
        }
    },
}
</script>
```

子组件，进阶写法：

```js
<template>
    <div v-show="show">
        我是子组件文字
        <button @click="$emit('change',false)">关闭</button>
    </div>
</template>
 
<script>
export default {
 // 子组件定义了以下代码就回改变默认字段
    model: {
       prop: "show",
       event: "change",
    },
    props: {
        show: {
            type: Boolean,
            default: false
        }
    },
}
</script>
```

子组件定义了以下代码就回改变默认字段

```js
model: {
       prop: "show",
       event: "change",
    },
```

**vue3的v-model：**

父组件：

```js
<script setup>
</script>

<template>
 <Chlid v-model="visible" />
</template>
```

子组件：

```js
<script setup>
const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])
</script>

<template>
  <input
    :value="props.modelValue"
    @input="emit('update:modelValue', $event.target.value)"
  />
</template>
```

## 4. 路由守卫

### 1.全局路由守卫

beforeEach(to, from, next) 全局前置守卫，路由跳转前触发

beforeResolve(to, from, next) 全局解析守卫 在所有组件内守卫和异步路由组件被解析之后触发

afterEach(to, from) 全局后置守卫，路由跳转完成后触发（注意没有 next 方法）

### 2.路由独享守卫

beforeEnter(to,from,next) 路由对象单个路由配置 ，单个路由进⼊前触发

### 3.组件路由守卫

beforeRouteEnter(to,from,next) 在组件⽣命周期beforeCreate阶段触发

beforeRouteUpdadte(to,from,next) 当前路由改变时触发

beforeRouteLeave(to,from,next) 导航离开该组件的对应路由时触发

### 4.参数

to： 即将要进⼊的⽬标路由对象

from： 即将要离开的路由对象

next(Function)：是否可以进⼊某个具体路由，或者是某个具体路由的路径

## 5. Vuex

Vuex有五个核⼼概念：state,getters,mutations,actions,modules

1. state：vuex的基本数据，⽤来存储状态数据
2. getters：从基本数据(state)派⽣的数据，相当于state的计算属性
3. **Mutations**：提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)。
4. **Actions**：像一个装饰器，包裹mutations，使之可以异步。（访问mutation使用ctx.commit；外界访问actions使用this.$store.dispatch() ）
5. **Modules**：对vuex进行模块化，可以让每一个模块拥有自己的state、getters、mutations、actions，使得结构更清晰，方便管理。

## 6. 组件通讯（⽗、⼦）

1. ⽗传子:  ⽗组件通过属性的⽅式向⼦组件传值，⼦组件通过 props 来接收

2. ⼦传父:  ⼦组件绑定⼀个事件，通过 this.$emit() 来触发

3. 其他⽅式：缓存、vuex、eventBus事件总线、provide / inject、父组件$refs获取子组件数据、子组件$parent获取父组件数据、    作用域插槽

## 7. 怎么定义vue-router的动态路由？

在router⽬录下的index.js⽂件中，对path属性加上/:id。 可以通过 this.$route.params.id 获取

## 8. 2.0和3.0的区别

双向绑定:

V2：使⽤Object.defineProperty

V3：使⽤ES6的新特性proxy来劫持数据，当数据改变时发出通知

根元素:

V2: 必须要有⼀个根元素

V3: ⽆要求

diff算法:

V2: 虚拟Dom全量⽐较

V3: 增加了静态标记PatchFlag

生命周期不同

## 9. computed 与 watch 的区别

computed⽀持缓存，相依赖的数据发⽣改变才会重新计算；watch不⽀持缓存，只要监听的数据变化就会触发相应操作

computed不⽀持异步，当computed内有异步操作时是⽆法监听数据变化的；watch⽀持异步操作

computed属性的属性值是⼀函数，函数返回值为属性的属性值，computed中每个属性都可以设置set与get⽅法。watch监听的数据必须是data中声明过或⽗组件传递过

**computed：**

1. 它是计算属性。主要用于值的计算并一般会返回一个值。所以它更多⽤于计算值的场景
2. 它具有缓存性。当访问它来获取值时，它的 getter 函数所计算出来的值会进行缓存
3. 只有当它依赖的属性值发生了改变，那下⼀次再访问时才会重新调⽤ getter 函数来计算
4. 它适⽤于计算⽐较消耗性能的计算场景
5. 必须要有一个返回值

**watch：**

1. 它更多的是起到 “观察” 的作⽤，类似于对数据进行变化的监听并执行回调。

   主要⽤于观察 `props` 或 本组件data的值，当这些值发生变化时，执⾏处理操作

2. 不一定要返回某个值

**建议：**

1. 当目的是进⾏数值计算，且依赖于其他数据，那么推荐使用 `computed`

2. 当需要在某个数据发生变化的, 同时做⼀些稍复杂的逻辑操作，那么推荐使⽤ `watch`

## 10.Route和router的区别

1. route:是路由信息对象，包括“path,parms,hash,name“等路由信息参数。

2. Router:是路由实例对象，包括了路由跳转⽅法（ this.$router.push() ），钩⼦函数等。

## 11.vue-router 路由模式有⼏种？

vue-router 有 3 种路由模式：hash、history、abstract：

hash: 使⽤ URL hash 值来作路由。⽀持所有浏览器，包括不⽀持 HTML5 History Api 的浏览器；(会有#)

history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；

abstract : ⽀持所有 JavaScript 运⾏环境，如 Node.js 服务器端。如果发现没有浏览器的API，路由会⾃动强制进⼊这个模式.

## 12. Object.defineProperty 和 Proxy 的区别

Object.defineProperty 和 Proxy 的区别如下:

1. Proxy 可以直接监听对象而非属性；&#x20;
2. Proxy 可以直接监听数组的变化；
3. Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等 是 Object.defineProperty 不具备的&#x20;
4. Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改
5. Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准 的性能红利&#x20;
6. Object.defineProperty 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题, 而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重 写

## 13. vue3 新特性有哪些？

1、性能提升

- 响应式性能提升，由原来的 Object.defineProperty 改为基于ES6的 Proxy ，使其速度更快，消除警告。
- 重写了 Vdom ，突破了 Vdom 的性能瓶颈。
-
- 进行模板编译优化。
- 更加高效的组件初始化

2、更好的支持 typeScript

- 有更好的类型推断，使得 Vue3 把 typeScript 支持得非常好

3、新增Composition API

- Composition API 是 vue3 新增的功能，比 mixin 更强大。它可以把各个功能模块独立开来，提高代码逻辑的可复用性，同时代码压缩性更强

4、新增组件

- Fragment 不再限制 template 只有一个根几点。
- Teleport 传送门，允许我们将控制的内容传送到任意的 DOM 中。
- Supense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验。

5、Tree-shaking：支持摇树优化

- 摇树优化后会将不需要的模块修剪掉，真正需要的模块打到包内。优化后的项目体积只有原来的一半，加载速度更快

6、Custom Renderer API： 自定义渲染器

- 实现 DOM 的方式进行 WebGL 编程

## 14. v-show 与 v-if 区别

v-show和v-if的区别：

v-show是css切换，v-if是完整的销毁和重新创建。

使⽤频繁切换时⽤v-show，运⾏时较少改变时⽤v-if

## 15. vue中v-if和v-for优先级在vue2和vue3中的区别

实践中不管是vue2或者vue3都不应该把v-if和v-for放在一起使用。

- 在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时， v-for 会优先作用。
- 在 vue 3.x 中， v-if 总是优先于 v-for 生效。
- vue2中v-for的优先级是高于v-if的，放在一起，会先执行循环在判断条件，并且如果值渲染列表中一小部分元素，也得再每次重渲染的时候遍历整个列表，比较浪费资源。
- vue3中v-if的优先级是高于v-for的，所以v-if执行时，它调用相应的变量如果不存在，就会导致异常

## 16. script setup 是干啥的？

scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：

- 属性和方法无需返回，可以直接使用。
- 引入组件的时候，会自动注册，无需通过 components 手动注册。
- 使用 defineProps 接收父组件传递的值。
- useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。
- 默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。

## 17. reactive与ref的区别？

Vue3 中的 ref 和 reactive 是 Vue3 中用于数据管理的两种不同的响应式 API。

ref 用于创建一个包装简单值的响应式引用，例如一个数字、字符串或对象。当 ref 创建一个响应式引用时，它返回一个对象，该对象具有一个 value 属性，该属性指向实际值。当 ref 返回的对象中的 value 属性更改时，组件将自动重新渲染。

reactive 用于创建一个响应式对象，该对象可以包含多个属性和嵌套属性。当使用 reactive 创建响应式对象时，返回的对象是一个代理对象，该对象具有与原始对象相同的属性，并且任何对代理对象属性的更改都将触发组件的重新渲染。

## 18. v-model的使用？

v-model实现双向绑定的语法糖，常用于表单与组件之间的数据双向绑定.

V-model的原理：

- v-bind绑定一个value属性

- v-on指令给当前元素绑定input事件

可看出v-model绑定在表单上时，v-model其实就是v-bind绑定value和v-on监听input事件的结合体

组件上的双向绑定（原理）

v-model绑定在组件上的时候做了以下步骤

- 在父组件内给子组件标签添加 v-model ，其实就是给子组件绑定了 value 属性
- 子组件内使用 prop 创建 创建 value 属性可以拿到父组件传递下来的值，名字必须是 value。
- 子组件内部更改 value 的时候，必须通过 $emit 派发一个 input 事件，并携最新的值
- v-model 会自动监听 input 事件，把接收到的最新的值同步赋值到 v-model 绑定的变量上

## 19. vuex中的辅助函数怎么使用？

vuex的辅助函数有4个

- mapState 函数返回的是一个对象。通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。
- mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，因此你可以这样来使用他
- mapMutations 辅助函数将组件中的 methods 映射为 store.commit，其原理就是将this.montify 映射为this.\$store.commit(‘montify’)
- mapActions在组件中使用 this.\$store.dispatch('prodect') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用

## 20. slot是什么？有什么作用？原理是什么？

slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。

**slot又分三类，默认插槽，具名插槽和作用域插槽。**

- 默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。
- 具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。
- 作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。

**实现原理：**

当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.\$slot中，默认插槽为vm.\$slot.default具名插槽为vm.\$slot.xxx，xxx 为插槽名

当组件执行渲染函数时候，遇到slot标签，使用slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽

## 21. \$nextTick的使用

用法：将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。

**\$nextTick() 的应用场景**

在vue的生命周期 created() 钩子函数中进行 dom 操作，一定要放在 \$nextTick() 函数中执行。在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 nextTick() 的回调函数中。

mounted() 钩子函数，因为该钩子函数执行时，所有的 DOM 挂载和 渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题

在数据变化后要执行某个操作，而这个操作需要随数据改变而改变DOM结构时，这个操作都是需要放置 \$nextTick() 的回调函数中。

```js
this.$nextTick(() => {
          console.log("使用方法")
        })
```

## 22. v-for中的key

**语法：** key="唯一值"

**作用：**给列表项添加的**唯一标识**。便于Vue进行列表项的**正确排序复用**。

**为什么加key：**Vue 的默认行为会尝试原地修改元素（**就地复用**）

实例代码：

```js
<ul>
  <li v-for="(item, index) in booksList" :key="item.id">
    <span>{{ item.name }}</span>
    <span>{{ item.author }}</span>
    <button @click="del(item.id)">删除</button>
  </li>
</ul>
```

注意：

1. **key 的值只能是字符串 或 数字类型**
2. **key 的值必须具有唯一性**
3. 推荐使用  id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）

## 23.data必须是一个函数

1. **data为什么要写成函数**

一个组件的 **data** 选项必须**是一个函数**。目的是为了：**保证每个组件实例**，维护**独立**的一份**数据**对象。

每次创建新的组件实例，都会新**执行一次data 函数**，得到一个新对象。

因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响

## **24.编程式导航，如何跳转传参？**

```js
methods: {  
  goToUser(userId) {  
    // 使用命名路由和params传递参数  
    this.$router.push({ name: 'user', params: { id: userId } });  
      

    // 或者使用path和query传递参数  
    // this.$router.push(`/user/${userId}`); // 这种方式也可以，但参数会出现在URL中  
    // 使用query参数不会出现在URL的路径部分，而是作为查询字符串出现  
    // this.$router.push({ path: '/user', query: { id: userId } });  

  }  
}
```

1. **在目标组件中接收参数**

在`User`组件中，你可以通过`$route.params`或`$route.query`来接收传递过来的参数。

```js
export default {  
  name: 'User',  
  data() {  
    return {  
      userId: null  
    };  
  },  
  created() {  
    // 如果是通过params传递的参数  
    this.userId = this.$route.params.id;  
      

    // 如果是通过query传递的参数  
    // this.userId = this.$route.query.id;  

  }  
};
```

1.path路径跳转

- query传参

  ```js
  this.$router.push('/路径?参数名1=参数值1&参数2=参数值2')
  
  this.$router.push({
    path: '/路径',
    query: {
      参数名1: '参数值1',
      参数名2: '参数值2'
    }
  })
  ```

- 动态路由传参

  ```js
  this.$router.push('/路径/参数值')
  
  this.$router.push({
    path: '/路径/参数值'
  })
  ```

2.name命名路由跳转

- query传参

  ```js
  this.$router.push({
    name: '路由名字',
    query: {
      参数名1: '参数值1',
      参数名2: '参数值2'
    }
  })
  ```

- 动态路由传参 (需要配动态路由)

  ```js
  this.$router.push({
    name: '路由名字',
    params: {
      参数名: '参数值',
    }
  })
  ```

## 25. 什么是 MVVM

MVVM是一种用于构建用户界面的软件架构模式，它将应用程序的逻辑和用户界面进行分离，以提高代码的可维护性和可测试性。MVVM 代表着 Model-View-ViewModel。

- Model（模型）：负责封装应用程序的数据和业务逻辑。模型表示应用程序的数据结构、状态和操作，通常包括数据获取、验证、持久化等功能。
- View（视图）：负责展示用户界面。视图是用户所看到和操作的界面，它通常由HTML、XML、XAML等表示。
- ViewModel（视图模型）：连接模型和视图之间的桥梁。视图模型具有与视图相对应的属性、命令和方法，用于展示数据、处理用户交互，并根据业务逻辑更新模型。

`Model-View-ViewModel 模式`

![hani](前端面试手册.assets/image-20210223221853817.png)

**Model 层**: `数据模型层`

通过 `Ajax`、`fetch` 等 API 完成客户端和服务端业务模型的同步。

**View 层**: `视图层`

作为视图模板存在，其实View 就是⼀个动态模板。

**ViewModel 层**: `视图模型层`

负责暴露数据给 View 层，并对 View 层中的数据绑定声明、 指令声明、 事件绑定声明, 进行实际的业务逻辑实现。

**`数据变化了, 视图自动更新`** => ViewModel 底层会做好监听Object.defineProperty，当数据变化时，View 层会自动更新

**`视图变化了, 绑定的数据自动更新`** =>  会监听双向绑定的表单元素的变化，⼀旦变化，绑定的数据也会得到⾃动更新。

## 26. MVVM的优缺点有哪些？

**优点：**

1. 实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性

2. 提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码

3. 能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来

**缺点：**

1. Bug 难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，

   也有可能是Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，

   要定位原始出问题的地⽅就变得不那么容易了

   可采用的`调试方案`:

   ```是登录校验通过之后，直接调用接口，获取token之后，跳转到主页。

- vue-element-admin的登录思路：

1. 登录表单校验通过
2. 调用Vuex提供的登录的action
3. 登录的Action中会调用接口
4. 登录接口如果成功执行，会返回token
5. 利用Vuex的特性，将token共享的到Vuex中，这样Vuex就统一管理了token,别的地方想要使用，直接通过Vuex就可以
6. 登录接口会调用单独封装的请求模块(api)
7. 请求模块中又会使用用到axios封装的请求工具
8. 而请求工具又要考虑区分 开发环境和生产环境的问题
9. 请求时还要考虑前后分离项目产生的跨域问题，要使用代理解决跨域

## axios封装

```js
import axios from 'axios'
import { getToken } from './auth'
import { Message } from 'element-ui'
// 1. 通用配置
// 2. 定制化的配置

// 通用配置

// 1. axios实例化 axios.create()  基地址配置baseURL + 超时时间timeout(100ms)
// 拓展一下:create方法可以调用多次 每次执行都会生成一个独一无二的实例
// export default const a = axios.create({baseURL:'a.com'})
// export default const b =  axios.create({baseURL:'b.com'})

// 2. 请求拦截器  请求头中添加token数据 接口鉴权 统一配置
// 客户端发送请求 - 请求拦截器(针对请求参数做处理) - 后端
// 拓展一下: 可以添加多个请求拦截器
// 客户端请求 -> 拦截器一(处理参数) -> 拦截器二 -> 后端

// 3. 响应拦截器  数据剥离res.data / 401错误处理 / 前端自定义错误处理？如果后端不管接口成功还是失败统一返回200
// 后端 -> 响应拦截器 -> 客户端
// 成功回调 200 - 300
// 失败回调 不在这个之间

const service = axios.create({
  baseURL: 'https://api-hmzs.itheima.net/v1',
  timeout: 5000 // request timeout
})

// 请求拦截器
service.interceptors.request.use(
  config => {
    // 添加token
    const token = getToken()
    if (token) {
      // 前面是固定的写法 后面的token的拼接模式由后端来决定
      config.headers.Authorization = token
    }
    return config
  },
  error => {
    return Promise.reject(error)
  }
)

// 响应拦截器
service.interceptors.response.use(
  response => {
    return response.data
  },
  // 接口出错的时候自动执行这个回调
  error => {
    console.dir(error.response.data.msg)
    // 错误类型有可能有好多种 根据不同的错误码做不同的的用户提示 写的位置都在这里
    Message({
      type: 'warning',
      message: error.response.data.msg
    })
    return Promise.reject(error)
  }
)

export default service

```

## 2.登录模块业务实现思路

1. 首先设计并开发出登录页面的静态页面，设置Rules校验函数，对手机号和密码实现校验。基础校验和统一校验。
2. 使用token 信息作为用户登录的唯一标识，并且存储在LocalStorage中，通过Vuex 统一管理token ，并且实现token 的持久化。
3. 利用 axios 中设置请求拦截器，在每次请求的请求头中，注入 token 信息，作为登录的标识。
4. 配合Vue-Router 中的beforeEach 前置导航守卫函数，实现对 token 信息的统一监测，和拦截登录。

## 3.主页模块的实现思路

1. 登录成功后，根据业务的需求，配合suss 实现对样式的二次修改。
2. 初始化 Vuex 中的 mutations 信息，更新登录后用户的信息收集，封装 action 获取用户资料
3. 利用 Vuex 中的 getters 属性，完成用户登陆后的视图层渲染
4. 封装 action ，实现用户退出登录，调用 commit 方法，清除 Vuex 中保存的 token 信息
5. 根据后端检测 token 返回的状态码，设置拦截器，对失效 token 信息实现拦截登录，并提示用户token失效

## 4.登录流程

1. 拉取 vue-admin-template 代码，进行一些改造。

2. 设计并且开发登录页面，进行表单校验，基础校验 + 统一校验

   ```html
   <!--
    基础校验
   el-form  :model="表单对象"  :rules="规则对象"
   el-form-item  prop属性指定一下要使用哪条规则
   el-input v-model双向绑定
   
   统一校验
   1. 获取表单的实例对象
   2. 调用validate方法    const res = await this.$refs.loginForm.validate() 
   -->
   ```

3. Vuex 中实现用户的模块

   1. 删除模板中原有的内容进行重写  

   2. 开启命名空间，导出 vuex 子模块

   3. 实现 token 的vue数据持久化

      ```js
      1. 存Token数据时，一份存入vuex，一份存入cookie
      2. vuex中初始化Token时，优先从本地cookie取，取不到再初始化为空串儿
      ```

   4. 实现登录的actions方法

      ```js
      login() {
            this.$refs.form.validate((isOK) => {
              if (isOK) {
                this.$store.dispatch("user/login", this.loginForm)
              }
            })
          }
      ```

4. Vue-cli 代理解决跨域：配置文件可以直接配置代理 vue.config.js  -> devServer  ->  proxy -> api

5. axios 二次封装，将 `axios`请求方法，封装到 request 模块

   1. 配置基础地址  ，超出时间

   2. 请求拦截器 - 根据获取仓库中的token 来判断  然后 在header 中统一注入 token

   3. 响应拦截器 - 解构数据  -  处理异常

      ```js
      // 通用配置
      // 1. axios实例化  axios.create() 基地址配置 baseURL + 超时时间 timeout（100ms）
      // 拓展：create方法可以调用多次 每次执行都会生成一个独一无二的实例
      // export default const a = asiox.create({ baseURL: 'a.com' })
      // export default const b = asiox.create({ baseURL: 'b.com' })
      
      // 2. 请求拦截器  请求头中添加token数据  接口鉴权  统一配置
      // 客户端发送请求 - 请求拦截器(针对请求参数做处理) - 后端
      // 拓展：可以添加多个请求拦截器
      // 客户端请求 - 拦截器1(处理参数) - 拦截器2 - 后端 
      // 最后一定要return  config  失败就执行promise.reject(error)
      
      // 3. 响应拦截器 数据剥离 res.data / token失效401错误处理 / 前端自定义错误处理？ 
      // 后端 - 响应拦截器 - 客户端
      // 成功回调 200-300
      // 失败回调 不在这个之间
      // axios默认包裹了一层data 把响应数据解构出来  判断如果业务成功 返回用户所需要的数据   业务失效 错误提示  return 一个error  （new一个）
      // // 所有的响应错误信息，统一处理
      
      ```

6. 封装 api 接口

   **将请求封装成方法，统一存放到 api 模块，与页面分离,可维护性高**

   新建 `api/user.js` 提供注册 Api 函数

   ```jsx
   import request from '@/utils/request'
   
   // 注册接口
   export const register = (data) => {
     return request.post('/user/register', data)
   }
   ```

7. 区分环境（表单）

   1. 开发环境  developent
   2. 生产环境   production

8. 登录联调

   1. 封装登录的api
   2. vuex 中的用户模块调用登录接口
   3. 登录成功后，跳转到主页
   4. 区分表单不同环境下的不同数据

9. 主页鉴权验证

   1. 访问主页-有token放过，没有token跳到登录页
   2. 访问登录-有token跳到主页，没有token放过
   3. 前置守卫 - beforeEach 中 来处理逻辑  白名单

## 5.智慧园区

### 1.搜索功能

  思路分析：把各种搜索条件当作请求参数发给后端 后端会根据字段对数据库数据做过滤筛选拿到符合条件返回

```txt
1. 表单组件的双向绑定收集到当前的请求数据
2. 把收集到的表单参数发送接口给后端那符合条件的数据
3. 把拿到的数据关系显示在列表中
```

### 2.excel导出

1. 实际开发过程中的导出

   1. 前端主导（xlsx）

      流程：调用列表接口把要导出的数据拿到 -> 数据的二次转化  ->  [excel 工作簿 - 工作表 - 单元格数据] - 使用xlsx创建一个工作簿 - 使用xlsx方法创建一个工作表 - 把工作表添加到工作簿 -- [使用中文替换中文表头] 调用xlsx的导出方法

      工作中遇到了需求，参考代码 换接口 数据二次处理 处理表头

   2. 后端主导（最常见）

      流程：前端直接调用导出接口 - 后端会把数据转换成excel文件流当成返回值返回 - 直接触发浏览器的下载功能

2. 两种方案的本质区别：

   把数据转化成excel的过程发生在哪里？如果发生在浏览器 前端主导 如果发生在后端服务器 后端主导

   前端主导 - 处理数据量不能太大

   后端主导 - 适合处理量大或量小都可

## 前端权限控制 - 菜单路由权限

### 基于RBAC的权限解决方案

RBAC:基于角色的权限控制方案

核心思路：给角色分配功能权限，把角色分配给员工，那员工就自动拥有了角色下面的所有功能权限

具体步骤：

**路由级别权限控制：**

接收后端的路由权限数据，与动态路由进行比较，生成最终用户可访问的路由表，然后配合 `router.addRoute` 动态注册路由，达到路由级的权限控制。之后再使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。

**按钮级别权限控制：**

封装全局指令，再vuex仓库里取出按钮权限数据，判断是否有相关的按钮权限，没有就使用 `el.remove()` 从DOM中移除。

## 接入微前端

微前端是一种前端架构模式，它将大型单体应用程序分解为小的、松散耦合的部分，每个部分都可以独立开发、测试和部署。微前端的好处如下：

1. 增强团队独立性

1. 提高可维护性

1. 提高性能

总之，微前端使开发人员可以更容易地构建、维护和扩展大型单体应用程序，从而提高了应用程序的质量和可靠性

微前端解决方案：

1. 乾坤
2. 无界

## 乾坤基础原理说明（直接观看拓展视频）

### 1. 基础运行原理

1. 监听路由变化
2. 匹配子应用
3. 加载子应用
4. 渲染子应用
